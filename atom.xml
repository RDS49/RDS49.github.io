<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>灰色の懒</title>
  
  <subtitle>灰色の懒</subtitle>
  <link href="https://rds49.github.io/atom.xml" rel="self"/>
  
  <link href="https://rds49.github.io/"/>
  <updated>2021-09-08T13:07:49.563Z</updated>
  <id>https://rds49.github.io/</id>
  
  <author>
    <name>灰色的懒</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://rds49.github.io/2021/09/08/Java/Java%E5%9F%BA%E7%A1%80/G1%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B/"/>
    <id>https://rds49.github.io/2021/09/08/Java/Java%E5%9F%BA%E7%A1%80/G1%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B/</id>
    <published>2021-09-08T13:04:26.169Z</published>
    <updated>2021-09-08T13:07:49.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="g1回收过程一-年轻代gc">G1回收过程一: 年轻代GC</h1><p>JVM启动时,G1先准备好Eden区,程序在运行过程中不断创建对象到Eden区,当Eden空间耗尽时,G1会启动一次年轻代垃圾回收过程。 <code>年轻代垃圾回收只会回收Eden区和Survivor区。</code> YGC时,首先G1停止应用程序的执行(Stop-The-World),G1创建回收集(Collection Set),回收集是指需要被回收的内存分段的集合,年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p><p>然后开始如下回收过程: <code>第一阶段,扫描根。</code> 根是指static变量指向的对象,正在执行的方法调用链条上的局部变量等。跟引用连同RSet记录的外部引用作为扫描存活对象的入口。 <code>第二阶段,更新RSet。</code> 处理dirty card queue(见备注)中的card,更新RSet。此阶段完成后,RSet可以准确的反映老年代对所在的内存分段中对象的引用。</p><blockquote><p>备注: 对于应用程序的引用赋值语句object.field=object,JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候,G1会对Dirty Card Queue中所有的card进行处理,以更新RSet,保证RSet实时准确的反映引用关系。 那为什么不在引用赋值语句处直接更新RSet呢?这是为了性能的需要,RSet的处理需要线程同步,开销会很大,使用队列性能会好很多。</p></blockquote><p><code>第三阶段,处理RSet。</code> 识别被老年代对象指向的Eden中的对象,这些被指向的Eden中的对象被认为是存活的对象。 <code>第四阶段,复制对象。</code> 此阶段,对象树被遍历,Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段,Survivor区内存段中存活的对象如果年龄未达阈值,年龄会加1,达到阈值会被复制到Old区中空的内存分段。如果Survivor空间不够,Eden空间的部分数据会直接晋升到老年代空间。 <code>第五阶段,处理引用。</code> 处理Soft,Weak,Phantom,Final,JNI Weak 等引用。最终Eden空间的数据为空,GC停止工作,而目标内存中的对象都是连续存储的,没有碎片,所以复制过程可以达到内存整理的效果,减少碎片。</p><h1 id="g1回收过程二-并发标记过程">G1回收过程二: 并发标记过程</h1><p><code>1. 初始标记阶段:</code> 标记从根节点直接可达的对象。这个阶段是STW的,并且会触发一次年轻代GC。 <code>2. 根区域扫描(Root Region Scanning):</code> G1 GC扫描survivor区直接可达的老年代区域对象,并标记被引用的对象。这一过程必须在young GC之前完成。 <code>3. 并发标记(Concurrent Marking):</code> 在整个堆中进行并发标记(和应用程序并发执行),此过程可能被young GC中断。在并发标记阶段,<code>若发现区域对象中的所有对象都是垃圾,那这个区域会被立即回收。</code>同时,并发标记过程中,会计算每个区域的对象活性(区域中存活对象的比例)。 <code>4. 再次标记(Remark):</code> 由于应用程序持续进行,需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照法: snapshot-at-the-beginning(SATB)。 <code>5. 独占清理(cleanup,STW):</code> 计算各个区域的存活对象和GC回收比例,并进行排序,识别可以混合回收的区域。为下阶段做铺垫。是STW的。 <code>6. 并发清理阶段:</code> 识别并清理完全空闲的区域。</p><h1 id="g1回收过程三-混合回收">G1回收过程三: 混合回收</h1><p>当越来越多的对象晋升到老年代old region时,为了避免堆内存被耗尽,虚拟机会触发一个混合的垃圾收集器,即Mixed GC,该算法并不是一个Old GC,除了回收整个Young Region,还会回收一部分的Old Region。这里需要注意: <code>是一部分老年代,而不是全部老年代</code>。可以选择哪些Old Region进行收集,从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p><figure><img src="https:////upload-images.jianshu.io/upload_images/14359229-8ca66837adb0e8d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/708/format/webp" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ul><li>并发标记结束以后,老年代中百分百为垃圾的内存分段被回收了,部分为垃圾的内存分段被计算了出来。默认情况下,这些老年代的内存分段会分8次(可以通过-XX:G1MixedGCCountTarget设置)被回收。</li><li>混合回收的回收集(Collection Set)包括八分之一的老年代内存分段,Eden区内存分段,Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样,只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li><li>由于老年代中的内存分段默认分8次回收,G1会优先回收垃圾多的内存分段。<code>垃圾占内存分段比例越高,越会被先回收</code>。并且有一个阈值会决定内存分段是否被回收。-XX:G1MixedGCLiveThresholdPercent,默认为65%,意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低,意味着存活的对象占比高,在复制的时候会花费更多的时间。</li><li>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent,默认值为10%,意思是允许整个堆内存中有10%的空间被浪费,意味着如果发现可以回收的垃圾占堆内存的比例低于10%,则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</li></ul><h1 id="g1回收可选的过程四-full-gc">G1回收可选的过程四: Full GC</h1><p>G1的初衷就是要避免Full GC的出现。按时如果上述方式不能正常工作,G1会<code>停止应用程序的执行</code>(Stop-The-World),使用<code>单线程</code>的内存回收算法进行垃圾回收,性能会非常差,应用程序停顿时间会很长。</p><p>要避免Full GC的发生,一旦发生需要进行调整。什么时候会发生Full GC呢?比如<code>堆内存太小</code>,当G1在复制存活对象的时候没有空的内存分段可用,则会回退到full gc,这种情况可以通过增大内存解决。</p><p>导致G1Full GC的原因可能有两个:</p><ol type="1"><li>Evacuation的时候没有足够的to-space来存放晋升的对象;</li><li>并发处理过程完成之前空间耗尽。</li></ol><p>作者：Shaw_Young 链接：https://www.jianshu.com/p/989429f646af 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;g1回收过程一-年轻代gc&quot;&gt;G1回收过程一: 年轻代GC&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rds49.github.io/2021/09/07/Java/Java%E5%9F%BA%E7%A1%80/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8/"/>
    <id>https://rds49.github.io/2021/09/07/Java/Java%E5%9F%BA%E7%A1%80/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8/</id>
    <published>2021-09-07T11:34:38.425Z</published>
    <updated>2021-09-07T11:35:06.974Z</updated>
    
    <content type="html"><![CDATA[<p>1，java.lang.NullPointerException</p><p>这个异常的解释是 "程序遇上了空指针 "，简单地说就是调用了未经初始化的对象或者是不存在的对象，这个错误经常出现在创建图片，调用数组这些操作中，比如图片未经初始化，或者图片创建时的路径错误等等。</p><p>2，java.lang.ClassNotFoundException</p><p>异常的解释是"指定的类不存在"，这里主要考虑一下类的名称和路径是否正确即可</p><p>3，java.lang.ArrayIndexOutOfBoundsException</p><p>这个异常的解释是"数组下标越界"，现在程序中大多都有对数组的操作，因此在调用数组的时候一定要认真检查，看自己调用的下标是不是超出了数组的范围，一般来说，显示（即直接用常数当下标）调用不太容易出这样的错，但隐式（即用变量表示下标）调用就经常出错了.</p><p>4，java.lang.NoSuchMethodError</p><p>方法不存在错误。当应用试图调用某类的某个方法，而该类的定义中没有该方法的定义时抛出该错误。</p><p>5，java.lang.IndexOutOfBoundsException</p><p>索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。</p><p>6，java.lang.NumberFormatException</p><p>数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;1，java.lang.NullPointerException&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>优先队列</title>
    <link href="https://rds49.github.io/2021/09/06/Java/Java%E5%9F%BA%E7%A1%80/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>https://rds49.github.io/2021/09/06/Java/Java%E5%9F%BA%E7%A1%80/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</id>
    <published>2021-09-06T06:35:18.894Z</published>
    <updated>2021-09-06T07:55:35.770Z</updated>
    
    <content type="html"><![CDATA[<p>优先队列在Java中的实现类PriorityQueue PriorityQueue是非线程安全的，所以Java提供了PriorityBlockingQueue（实现BlockingQueue接口）用于Java多线程环境。 优先队列：顾名思义就是优先级可以自定义 在实际的开发中我们经常会有后来居上的问题，比如定时任务，后面新建的任务，时间间隔短，可能先执行 <strong>那么优先级是如何自定义的呢？</strong> 使用比较器 使用比较器comparator，为什么不使用comparable，因为comparator不需要对原来的类进行修改，耦合度低 例子： <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span>  <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>       <span class="token comment">//匿名内部类实现比较器</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">></span></span>  cp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Person</span> o1<span class="token punctuation">,</span> <span class="token class-name">Person</span> o2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span>  o1<span class="token punctuation">.</span>age<span class="token operator">-</span>o2<span class="token punctuation">.</span>age<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>      <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">></span></span> pq<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token class-name">Person</span> p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token class-name">Person</span> poll <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>poll<span class="token punctuation">.</span>age<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>poll<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出 <pre class="line-numbers language-none"><code class="language-none">0 a0 a0 a1 a2 a2 a3 a3 a3 a6 a6 a10 a11 a12 a12 a12 a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> 可以看到队列中的数据是按照age的大小来排的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;优先队列在Java中的实现类PriorityQueue PriorityQueue是非线程安全的，所以Java提供了PriorityBlockingQueue（实现BlockingQueue接口）用于Java多线程环境。 优先队列：顾名思义就是优先级可以自定义 在实际的开发中我们经常会有后来居上的问题，比如定时任务，后面新建的任务，时间间隔短，可能先执行 &lt;strong&gt;那么优先级是如何自定义的呢？&lt;/strong&gt; 使用比较器 使用比较器comparator，为什么不使用comparable，因为comparator不需要对原来的类进行修改，耦合度低 例子： &lt;pre class=&quot;line-numbers language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&amp;#123;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt;  &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; age&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; age&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&amp;#123;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;age &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; age&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;&amp;#125;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;&amp;#125;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://rds49.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://rds49.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://rds49.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>comparable 与comparator</title>
    <link href="https://rds49.github.io/2021/09/06/Java/Java%E5%9F%BA%E7%A1%80/%E6%AF%94%E8%BE%83%E5%99%A8/"/>
    <id>https://rds49.github.io/2021/09/06/Java/Java%E5%9F%BA%E7%A1%80/%E6%AF%94%E8%BE%83%E5%99%A8/</id>
    <published>2021-09-06T06:22:51.817Z</published>
    <updated>2021-09-06T07:55:07.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="comparable-与comparator">comparable 与comparator</h2><h3 id="comparable">comparable</h3><p>内比较器：为什么叫内比较器，因为比较函数需要在需要比较的类中重写，</p><pre><code>               也就是说，当某个类需要增加此项功能时，需要在原来的代码上修改，耦合度高 可以自己与自己比较，comparator不支持自己与自己比较        例子：</code></pre><p>例如此时设计一个学生类，包含姓名、年龄、成绩，并产生一个对象数组，要求按成绩由高到底排序，如果成绩相等，则按年龄由低到高排序。 此时如果直接编写排序操作会比较麻烦，所以可以==使用 Arrays 类中的 sort() 方法进行排序操作。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token comment">//指定类型为 Student</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">float</span> score<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">,</span><span class="token keyword">float</span> score<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>score <span class="token operator">=</span> score<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> name <span class="token operator">+</span> <span class="token string">"\t\t"</span> <span class="token operator">+</span> age <span class="token operator">+</span> <span class="token string">"\t\t"</span> <span class="token operator">+</span> score<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Student</span> stu<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//覆写 compareTo() 方法，实现排序规则的应用</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>score<span class="token operator">></span>stu<span class="token punctuation">.</span>score<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>score <span class="token operator">&lt;</span> stu<span class="token punctuation">.</span>score<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">></span> stu<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">&lt;</span>stu<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Root</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Student</span><span class="token punctuation">[</span><span class="token punctuation">]</span> stu <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"stu1"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">90.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"stu2"</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">90.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"stu3"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">70.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"stu4"</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">98</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Student</span> x<span class="token operator">:</span>stu<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="comparator">comparator</h3><p>外比较器：相当于新建立一个类，具有对其他类进行比较的功能，不需要在原来的代码上进行修改，解耦了</p><pre class="line-numbers language-none"><code class="language-none">public class Person &#123;    public String name;    public Integer age;&#125;&#x2F;&#x2F; person类的Compartor比较器  泛型类型为Person&#x2F;&#x2F; 按照public class PersonCompartor implements Comparator&lt;Person&gt; &#123;    @Override    public int compare(Person o1, Person o2) &#123;        return o1.getAge()-o2.getAge();    &#125;&#125;&#x2F;&#x2F; 测试    public static void main(String[] args) &#123;        Person[] people &#x3D; new Person[]&#123;new Person(&quot;fsx&quot;, 18), new Person(&quot;dy&quot;, 15)&#125;;        System.out.println(&quot;排序前：&quot; + StringUtils.arrayToCommaDelimitedString(people));        Arrays.sort(people, new PersonCompartor()); &#x2F;&#x2F; 使用自定义的比较器排序        System.out.println(&quot;排序后：&quot; + StringUtils.arrayToCommaDelimitedString(people));    &#125;结果：排序前：Person&#123;name&#x3D;&#39;fsx&#39;, age&#x3D;18&#125;,Person&#123;name&#x3D;&#39;dy&#39;, age&#x3D;15&#125;排序后：Person&#123;name&#x3D;&#39;dy&#39;, age&#x3D;15&#125;,Person&#123;name&#x3D;&#39;fsx&#39;, age&#x3D;18&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;comparable-与comparator&quot;&gt;comparable 与comparator&lt;/h2&gt;</summary>
    
    
    
    <category term="Java" scheme="https://rds49.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://rds49.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://rds49.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>公平锁 非公平锁</title>
    <link href="https://rds49.github.io/2021/09/03/Java/%E5%85%AC%E5%B9%B3%E9%94%81%20%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/"/>
    <id>https://rds49.github.io/2021/09/03/Java/%E5%85%AC%E5%B9%B3%E9%94%81%20%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/</id>
    <published>2021-09-03T00:46:10.257Z</published>
    <updated>2021-09-03T00:50:50.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="公平锁和非公平锁">公平锁和非公平锁</h1><p>公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</p><p>优点：所有的线程都能得到资源，不会饿死在队列中。 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。 非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p><p>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。 缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;公平锁和非公平锁&quot;&gt;公平锁和非公平锁&lt;/h1&gt;</summary>
    
    
    
    <category term="Java" scheme="https://rds49.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://rds49.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://rds49.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Mysql面经</title>
    <link href="https://rds49.github.io/2021/09/01/%E9%9D%A2%E7%BB%8F/mysql/"/>
    <id>https://rds49.github.io/2021/09/01/%E9%9D%A2%E7%BB%8F/mysql/</id>
    <published>2021-09-01T10:33:58.896Z</published>
    <updated>2021-09-05T05:43:03.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="binlogredo-log和undo-log">binlog、redo log和undo log</h1><p>一、重做日志（redo log） 作用：</p><p>确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</p><p>二、回滚日志（undo log） 作用：</p><p>保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</p><p>三、二进制日志（binlog）： 作用：</p><p>用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。 用于数据库的基于时间点的还原。</p><p>对于InnoDB存储引擎而言，只有在事务提交时才会记录biglog，此时记录还在内存中，那么biglog是什么时候刷到磁盘中的呢？mysql通过sync_binlog参数控制biglog的刷盘时机，取值范围是0-N：</p><h1 id="慢查询">慢查询</h1><p>时间超过long_query_time(默认为10s，实际开发肯定不会这么短)的SQL语句， MySQL记录在慢查询日志中，以便于进行优化</p><h1 id="跳表">跳表</h1><p><a href="https://www.bilibili.com/video/BV1QK4y1Y7mS?from=search&amp;seid=1081014470129422905&amp;spm_id_from=333.337.0.0">跳表讲解视频</a> 由于链表在存储数据时，便于增删，不便于查询，于是就想出了用空间换时间的方法，对链表添加索引 <img src="/2021/09/01/%E9%9D%A2%E7%BB%8F/mysql/01.png" alt="跳表图"> # 高速三级缓存 CPU缓存是什么 CPU缓存（Cache Memory）是位于CPU与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。CPU高速缓存的出现主要是为了解决CPU运算速度与内存读写速度不匹配的矛盾，因为CPU运算速度要比内存读写速度快很多，这样会使CPU花费很长时间等待数据到来或把数据写入内存。在缓存中的数据是内存中的一小部分，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可先缓存中调用，从而加快读取速度。</p><p>当CPU需要读取数据并进行计算时，首先需要将CPU缓存中查到所需的数据，并在最短的时间下交付给CPU。如果没有查到所需的数据，CPU就会提出“要求”经过缓存从内存中读取，再原路返回至CPU进行计算。而同时，把这个数据所在的数据也调入缓存，可以使得以后对整块数据的读取都从缓存中进行，不必再调用内存。</p><p>缓存大小是CPU的重要指标之一，而且缓存的结构和大小对CPU速度的影响非常大，CPU内缓存的运行频率极高，一般是和处理器同频运作，工作效率远远大于系统内存和硬盘。实际工作时，CPU往往需要重复读取同样的数据块，而缓存容量的增大，可以大幅度提升CPU内部读取数据的命中率，而不用再到内存或者硬盘上寻找，以此提高系统性能。但是从CPU芯片面积和成本的因素来考虑，缓存都很小。</p><p>CPU一级缓存、二级缓存、三级缓存是什么意思？ ## 一级缓存（L1 Cache）</p><p>CPU一级缓存，就是指CPU的第一层级的高速缓存，主要当担的工作是缓存指令和缓存数据。一级缓存的容量与结构对CPU性能影响十分大，但是由于它的结构比较复杂，又考虑到成本等因素，一般来说，CPU的一级缓存较小，通常CPU的一级缓存也就能做到256KB左右的水平。</p><h2 id="二级缓存l2-cache">二级缓存（L2 Cache）</h2><p>CPU二级缓存，就是指CPU的第二层级的高速缓存，而二级缓存的容量会直接影响到CPU的性能，二级缓存的容量越大越好。例如intel的第八代i7-8700处理器，共有六个核心数量，而每个核心都拥有256KB的二级缓存，属于各核心独享，这样二级缓存总数就达到了1.5MB。</p><h2 id="三级缓存l3-cache">三级缓存（L3 Cache）</h2><p>CPU三级缓存，就是指CPU的第三层级的高速缓存，其作用是进一步降低内存的延迟，同时提升海量数据量计算时的性能。和一级缓存、二级缓存不同的是，三级缓存是核心共享的，能够将容量做的很大。 <img src="/2021/09/01/%E9%9D%A2%E7%BB%8F/mysql/02.jpg"> 按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存，二级缓存，如今主流CPU还有三级缓存，甚至有些CPU还有四级缓存。每一级缓存中所储存的全部数据都是下一级缓存的一部分，这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。</p><p>为什么CPU会有L1、L2、L3这样的缓存设计？主要是因为现在的处理器太快了，而从内存中读取数据实在太慢（一个是因为内存本身速度不够，另一个是因为它离CPU太远了，总的来说需要让CPU等待几十甚至几百个时钟周期），这个时候为了保证CPU的速度，就需要延迟更小速度更快的内存提供帮助，而这就是缓存。</p><p>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。一般来说，每级缓存的命中率大概都在80%左右，也就是说全部数据量的80%都可以在一级缓存中找到，只剩下20%的总数据量才需要从二级缓存、三级缓存或内存中读取，由此可见一级缓存是整个CPU缓存架构中最为重要的部分。</p><p>简介：CPU缓存是CPU一个重要的组成部分，大家都知道三级缓存的重要性，但是知不知道三级缓存意味着什么，是不是三级缓存越大越好呢？让我们一起来看一下吧。</p><p>缓存这个词想必大家都听过，其实缓存的意义很广泛：电脑整机最大的缓存可以体现为内存条、显卡上的显存就是显卡芯片所需要用到的缓存、硬盘上也有相对应的缓存、CPU有着最快的缓存（L1、L2、L3缓存等），缓存就是数据交换的缓冲区（称作Cache）。缓存往往都是RAM（断电即掉的非永久储存），它们的作用就是帮助硬件更快地响应。我们今天就来讲一下，关于最快的缓存——CPU缓存的那些事。</p><h2 id="为什么cpu缓存会分为一级缓存l1l2l3有什么意义">为什么CPU缓存会分为一级缓存L1、L2、L3？有什么意义？</h2><p><strong>CPU缓存是什么？</strong></p><p>CPU缓存的定义为CPU与内存之间的临时数据交换器，它的出现是为了解决CPU运行处理速度与内存读写速度不匹配的矛盾——缓存的速度比内存的速度快多了。CPU缓存一般直接跟CPU芯片集成或位于主板总线互连的独立芯片上。（现阶段的CPU缓存一般直接集成在CPU上）CPU往往需要重复处理相同的数据、重复执行相同的指令，如果这部分数据、指令CPU能在CPU缓存中找到，CPU就不需要从内存或硬盘中再读取数据、指令，从而减少了整机的响应时间。</p><figure><img src="http://t11.baidu.com/it/u=3943737202,1186243358&amp;fm=173&amp;app=25&amp;f=JPEG?w=305&amp;h=157&amp;s=08AFC812C0E87D09625A4DC9030070E2" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>CPU-缓存-主内存图示，图片来自：CPU Caches</p><p><strong>CPU缓存速度和内存速度差多少？</strong></p><p>我们来简单地打个比方：如果CPU在L1一级缓存中找到所需要的资料要用的时间为3个周期左右，那么在L2二级缓存找到资料的时间就要10个周期左右，L3三级缓存所需时间为50个周期左右；如果要到内存上去找呢，那就慢多了，可能需要几百个周期的时间。</p><figure><img src="http://t12.baidu.com/it/u=1815501872,194432455&amp;fm=173&amp;app=25&amp;f=JPEG?w=603&amp;h=175&amp;s=1C8A5C32C5204D204EDD55DA010090B2" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>I3-8300处理器技术规格</p><p>对CPU缓存有一定了解了吗，让我们再深入一点。以Intel为例，Intel官网上产品-处理器界面内对缓存的定义为：“CPU高速缓存是处理器上的一个快速记忆区域。英特尔智能高速缓存（SmartCache）是指可让所有内核动态共享最后一级高速缓存的架构。”这里就提及到了最后一级高速缓存的概念，即为CPU缓存中的L3(三级缓存)，那么我们继续来解释一下什么叫三级缓存，分别又是指哪三级缓存。</p><figure><img src="http://t10.baidu.com/it/u=421192332,1168975754&amp;fm=173&amp;app=25&amp;f=JPEG?w=305&amp;h=273&amp;s=60BE38D2122E54A882D8CB50030080F6" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>CPU-缓存-主内存图示，图片来自：CPU Caches</p><p><strong>三级缓存（L1、L2、L3）是什么？</strong></p><p>以近代CPU的视角来说，三级缓存（包括L1一级缓存、L2二级缓存、L3三级缓存）都是集成在CPU内的缓存，它们的作用都是作为CPU与主内存之间的高速数据缓冲区，L1最靠近CPU核心；L2其次；L3再次。运行速度方面：L1最快、L2次快、L3最慢；容量大小方面：L1最小、L2较大、L3最大。CPU会先在最快的L1中寻找需要的数据，找不到再去找次快的L2，还找不到再去找L3，L3都没有那就只能去内存找了。L1、L2、L3可以说是各有特点，下面我们就分开来讲一下。</p><p><strong>一级缓存（L1 Cache）</strong></p><p>一级缓存这个名词出现应该是在Intel公司Pentium处理器时代把缓存开始分类的时候，当时在CPU内部集成的CPU缓存已经不能满足整机的性能需求，而制造工艺上的限制不能在CPU内部大幅提高缓存的数量，所以出现了集成在主板上的缓存，当时人们把CPU内部集成的CPU缓存成为一级缓存，在CPU外部主板上的缓存称为二级缓存。</p><figure><img src="http://t10.baidu.com/it/u=193159914,3725572301&amp;fm=173&amp;app=25&amp;f=JPEG?w=220&amp;h=180&amp;s=3D0AF51012C64AE440985D430300C0E2" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>Intel Pentium 4</p><p>而一级缓存其实还分为一级数据缓存（Data Cache，D-Cache，L1d）和一级指令缓存(Instruction Cache，I-Cache，L1i)，分别用于存放数据及执行数据的指令解码，两者可同时被CPU访问，减少了CPU多核心、多线程争用缓存造成的冲突，提高了处理器的效能。一般CPU的L1i和L1d具备相同的容量，例如I7-8700K的L1即为32KB+32KB。</p><p><strong>二级缓存（L2 Cache）</strong></p><p>随着CPU制造工艺的发展，本来处于CPU外部的二级缓存也可以轻易地集成进CPU内部，这种时候再用缓存是否处于CPU内部来判断一二级缓存已经不再确切。集成进CPU的L2二级缓存运行速率渐渐可以跟上CPU的运行速度了，，其主要作用为当CPU在L1中没读取到所需要的数据时再把数据展示给CPU筛选（CPU未命中L1的情况下继续在L2寻求命中，缓存命中的工作原理我们稍后再讲）。</p><p>L2二级缓存比L1一级缓存的容量要更大，但是L2的速率要更慢，为什么呢？首先L2比L1要更远离CPU核心，L1是最靠近CPU核心的缓存，CPU需要读取L2的数据从物理距离上比L1要更远；L2的容量比L1更大，打个简单的比喻，在小盒子里面找东西要比在大房间里面找要方便快捷。这里也可以看出，缓存并非越大越好，越靠近CPU核心的缓存运行速率越快越好，非最后一级缓存的缓存容量自然是够用即可。</p><figure><img src="http://t10.baidu.com/it/u=3900381282,3674434332&amp;fm=173&amp;app=25&amp;f=JPEG?w=449&amp;h=552&amp;s=8563F4126AB829AB651E84C3030030BB" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>Core Duo酷睿双核处理器</p><p>L2二级缓存实际上就是L1一级缓存跟主内存之间的缓冲器，在2006年的时间点上，Intel和AMD当家在售的几款处理器可以看出他们对最后一级缓存不同的见解：Intel Core Duo不同于它的前辈Pentium D、EE，采用了双核心共享的2M L2二级缓存，是属于当时最先二级缓存架构，即“Smart Cache”共享缓存技术，这种技术沿用到以后的Intel推出的所有多核心处理器上；而AMD Athlon 64 X2处理器则是每个CPU核心都具备独立的二级缓存，Manchester核心的处理器为每核心512KB、Toledo核心为每核心1MB，两个核心之间的缓存的数据同步是通过CPU内置的SRI（系统请求接口）控制，这样的数据延迟及占用资源情况都要比Intel的Pentium D、EE核心要好，但还是比不上Core为代表的Smart Cache缓存共享。</p><p><strong>三级缓存（L3 Cache）</strong></p><p>最初出现L3三级缓存的应该是AMD的K6-III处理器，当时受限于制造工艺，L3只能集成在主板上。然后Intel首次出现L3三级缓存的是Itanium安腾服务器处理器，接着就是P4EE和至强MP。L3三级缓存的出现其实对CPU性能提升呈一个爬坡曲线——L3从0到2M的情况CPU性能提升非常明显，L3从2M到6M提升可能就只有10%不到了，这是在近代CPU多核共享L3的情况下；当L3集成进CPU正式成为CPU内部缓存后，CPU处理数据时只有5%需要在内存中调用数据，进一步地减少了内存延迟，使系统的响应更为快速。</p><figure><img src="http://t11.baidu.com/it/u=154948657,3853925851&amp;fm=173&amp;app=25&amp;f=JPEG?w=640&amp;h=358&amp;s=F99740960CF4FE9E488115D2030040B1" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>Intel Nehalem L3 SmartCache示意图</p><p>同理，L3即为L2与主内存之间的缓冲器，主要体现在提升处理器大数据处理方面的性能，对游戏表现方面有较大的帮助。那么也许有人就会问了，是不是选择CPU的时候看准L3买，哪个CPU的L3大就买哪个？非也，只有同架构的情况下这种比较才具有意义，先举个比较久远的例子：Intel具备1MB L3的Xeon MP处理器仍然不是AMD没有L3的皓龙处理器对手，再来个现有的：Intel I7-8700K 12MB L3和AMD Threadripper 1950X 32MB L3相比，自然是32MB比12MB大，但是平均下来也是一个核心2MB L3，性能就见仁见智了。</p><p><strong>CPU缓存是怎样帮助CPU工作的呢</strong></p><p>知道了L1、L2、L3的由来，我们再深入地了解一下CPU缓存是怎么帮助CPU提高工作效率的。</p><figure><img src="http://t10.baidu.com/it/u=1439505066,1546849489&amp;fm=173&amp;app=25&amp;f=JPEG?w=640&amp;h=480&amp;s=0496E932118E44E91650F0DA00008033" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>局限性原理，图片来自：CMU</p><p>由于数据的局限性，CPU往往需要在短时间内重复多次读取数据，内存的运行频率自然是远远跟不上CPU的处理速度的，怎么办呢？缓存的重要性就凸显出来了，CPU可以避开内存在缓存里读取到想要的数据，称之为命中（hit）。L1的运行速度很快，但是它的数据容量很小，CPU能在L1里命中的概率大概在80%左右——日常使用的情况下；L2、L3的机制也类似如此，这样一来，CPU需要在内存中读取的数据大概为5%-10%，其余数据命中全部可以在L1、L2、L3中做到，大大减少了系统的响应时间，总的来说，所有CPU读取数据的顺序都是先缓存再内存。</p><p>L1、L2、L3缓存跟内存速度相差很大，它们构成上的不同导致了其速度的差距，那么CPU缓存和内存分别是怎样构成的呢？</p><p><strong>缓存SRAM与内存DRAM的区别</strong></p><p>CPU缓存基本由SRAM（Static RAM，静态RAM）构成，内存的DRAM其实是SDRAM（同步动态随机储存器），是DRAM（Dynamic RAM，动态）的一种。</p><figure><img src="http://t11.baidu.com/it/u=1446718939,2123260771&amp;fm=173&amp;app=25&amp;f=JPEG?w=115&amp;h=77&amp;s=7FAE346281F171885E5454C60000C0B1" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>DRAM</p><p>DRAM只含一个晶体管和一个电容器，集成度非常高，可以轻松做出大容量（内存），但是因为靠电容器来储存信息，所以需要不断刷新补充电容器的电荷，充电放电之间的时间差导致了DRAM比SRAM的反应要缓慢得多。</p><figure><img src="http://t12.baidu.com/it/u=1539953852,3622963659&amp;fm=173&amp;app=25&amp;f=JPEG?w=249&amp;h=169&amp;s=5AA83C62D38658E81CFCA1DE0000E0B1" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>SRAM</p><p>SRAM相比DRAM的复杂度就高了不止一筹，所以导致SRAM的集成度很低——前期CPU缓存不能集成进CPU内部也有这个原因。SRAM的特点就是快，有电就有数据，不需要刷新时间所以凸显其数据传输速度很快，缺点就是占据面积大、成本低。假如一个DRAM占据一个单位的地方，一个SRAM就要占据六个单位的地方，差别还是挺大的。</p><p><strong>番外：L4四级缓存和eDRAM</strong></p><figure><img src="http://t12.baidu.com/it/u=3322490243,200036758&amp;fm=173&amp;app=25&amp;f=JPEG?w=639&amp;h=363&amp;s=59B0AC521A616E845119E1470300F0E3" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>I7-4750H</p><p>并不是每个CPU都会使用SRAM作为CPU缓存，IBM的Power系列处理器就使用了eDRAM作为CPU缓存；我们再看看Intel Haswell I7-4750H这个CPU，其主要受关注的地方在于CPU内嵌入了128MB的eDRAM作为显存让核心显卡Iris Pro 5200使用，在不使用核心显卡的时候，128MB eDRAM将会成为处理器的L4四级缓存。当然了，I7-4750H多了L4之后在处理器性能上也没提高多少，eDram缓存的主要作用还是在于给核心显卡当显存上。</p><h1 id="怎么从0到1设计并组织团队完成一个高并发高可用的项目">怎么从0到1，设计并组织团队完成一个高并发、高可用的项目</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;binlogredo-log和undo-log&quot;&gt;binlog、redo log和undo log&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://rds49.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="Java" scheme="https://rds49.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 锁</title>
    <link href="https://rds49.github.io/2021/09/01/Java/%E9%94%81/"/>
    <id>https://rds49.github.io/2021/09/01/Java/%E9%94%81/</id>
    <published>2021-09-01T05:30:50.134Z</published>
    <updated>2021-09-03T00:36:36.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不可不说的java锁事"><a href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java“锁”事</a></h1><p>2018年11月15日 作者: 家琪 <a href="https://tech.meituan.com/2018/11/15/java-lock.html">文章链接</a> 13658字 28分钟阅读</p><h2 id="前言">前言</h2><p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8和Netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。</p><p>Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录：</p><figure><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h3 id="乐观锁-vs-悲观锁">1. 乐观锁 VS 悲观锁</h3><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。</p><p>先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p><p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</p><p>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p><figure><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/c8703cd9.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>根据从上面的概念描述我们可以发现：</p><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li><li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><p>光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; ------------------------- 悲观锁的调用方式 -------------------------&#x2F;&#x2F; synchronizedpublic synchronized void testMethod() &#123;&#x2F;&#x2F; 操作同步资源&#125;&#x2F;&#x2F; ReentrantLockprivate ReentrantLock lock &#x3D; new ReentrantLock(); &#x2F;&#x2F; 需要保证多个线程使用的是同一个锁public void modifyPublicResources() &#123;lock.lock();&#x2F;&#x2F; 操作同步资源lock.unlock();&#125;&#x2F;&#x2F; ------------------------- 乐观锁的调用方式 -------------------------private AtomicInteger atomicInteger &#x3D; new AtomicInteger();  &#x2F;&#x2F; 需要保证多个线程使用的是同一个AtomicIntegeratomicInteger.incrementAndGet(); &#x2F;&#x2F;执行自增1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。</p><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><p>之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：</p><figure><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/feda866e.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>根据定义我们可以看出各属性的作用：</p><ul><li>unsafe： 获取并操作内存的数据。</li><li>valueOffset： 存储value在AtomicInteger中的偏移量。</li><li>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</li></ul><p>接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; ------------------------- JDK 8 -------------------------&#x2F;&#x2F; AtomicInteger 自增方法public final int incrementAndGet() &#123;  return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125;&#x2F;&#x2F; Unsafe.classpublic final int getAndAddInt(Object var1, long var2, int var4) &#123;  int var5;  do &#123;      var5 &#x3D; this.getIntVolatile(var1, var2);  &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));  return var5;&#125;&#x2F;&#x2F; ------------------------- OpenJDK 8 -------------------------&#x2F;&#x2F; Unsafe.javapublic final int getAndAddInt(Object o, long offset, int delta) &#123;   int v;   do &#123;       v &#x3D; getIntVolatile(o, offset);   &#125; while (!compareAndSwapInt(o, offset, v, v + delta));   return v;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p><p>后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。</p><p>CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：</p><ol type="1"><li><p>ABA问题</p><p>。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p><ul><li>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li></ul></li><li><p><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p></li><li><p>只能保证一个共享变量的原子操作</p><p>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p><ul><li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li></ul></li></ol><h3 id="自旋锁-vs-适应性自旋锁">2. 自旋锁 VS 适应性自旋锁</h3><p>在介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。</p><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p><p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><figure><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/452a3363.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><figure><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/83b3f85e.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><p>在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock，本文中仅做名词介绍，不做深入讲解，感兴趣的同学可以自行查阅相关资料。</p><h3 id="无锁-vs-偏向锁-vs-轻量级锁-vs-重量级锁">3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h3><p>这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。</p><p>首先为什么Synchronized能实现线程同步？</p><p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p><h4 id="java对象头">Java对象头</h4><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p><p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p><p><strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p><p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h4 id="monitor">Monitor</h4><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p><p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><p>现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p><p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p><p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p><table><thead><tr class="header"><th style="text-align: left;">锁状态</th><th style="text-align: left;">存储内容</th><th style="text-align: left;">存储内容</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">无锁</td><td style="text-align: left;">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td><td style="text-align: left;">01</td></tr><tr class="even"><td style="text-align: left;">偏向锁</td><td style="text-align: left;">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td><td style="text-align: left;">01</td></tr><tr class="odd"><td style="text-align: left;">轻量级锁</td><td style="text-align: left;">指向栈中锁记录的指针</td><td style="text-align: left;">00</td></tr><tr class="even"><td style="text-align: left;">重量级锁</td><td style="text-align: left;">指向互斥量（重量级锁）的指针</td><td style="text-align: left;">10</td></tr></tbody></table><p><strong>无锁</strong></p><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p><p><strong>偏向锁</strong></p><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p><p><strong>轻量级锁</strong></p><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p><p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p><p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p><p><strong>重量级锁</strong></p><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><p>整体的锁状态升级流程如下：</p><figure><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8afdf6f2.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p><h3 id="公平锁-vs-非公平锁">4. 公平锁 VS 非公平锁</h3><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><p>直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。</p><figure><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/a23d746a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p><p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：</p><figure><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/4499559e.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。</p><figure><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/6edea205.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p><p>下面我们来看一下公平锁与非公平锁的加锁方法的源码:</p><figure><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/bc6fe583.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。</p><figure><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/bd0036bb.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</p><p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p><h3 id="可重入锁-vs-非可重入锁">5. 可重入锁 VS 非可重入锁</h3><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Widget &#123;    public synchronized void doSomething() &#123;        System.out.println(&quot;方法1执行...&quot;);        doOthers();    &#125;    public synchronized void doOthers() &#123;        System.out.println(&quot;方法2执行...&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。</p><p>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><p>而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。</p><p>还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p><figure><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/58fc5bc9.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p><figure><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ea597a0c.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。</p><p>首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。</p><p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p><p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p><figure><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/32536e7a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h3 id="独享锁-vs-共享锁">6. 独享锁 VS 共享锁</h3><p>独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。</p><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p><p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p><p>下图为ReentrantReadWriteLock的部分源码：</p><figure><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/762a042b.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p><p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p><p>那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。 在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p><p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：</p><figure><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8793e00a.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>了解了概念之后我们再来看代码，先看写锁的加锁源码：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">protected final boolean tryAcquire(int acquires) &#123;Thread current &#x3D; Thread.currentThread();int c &#x3D; getState(); &#x2F;&#x2F; 取到当前锁的个数int w &#x3D; exclusiveCount(c); &#x2F;&#x2F; 取写锁的个数wif (c !&#x3D; 0) &#123; &#x2F;&#x2F; 如果已经有线程持有了锁(c!&#x3D;0)    &#x2F;&#x2F; (Note: if c !&#x3D; 0 and w &#x3D;&#x3D; 0 then shared count !&#x3D; 0)if (w &#x3D;&#x3D; 0 || current !&#x3D; getExclusiveOwnerThread()) &#x2F;&#x2F; 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败return false;if (w + exclusiveCount(acquires) &gt; MAX_COUNT)    &#x2F;&#x2F; 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。      throw new Error(&quot;Maximum lock count exceeded&quot;);&#x2F;&#x2F; Reentrant acquire    setState(c + acquires);    return true;  &#125;  if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#x2F;&#x2F; 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。return false;setExclusiveOwnerThread(current); &#x2F;&#x2F; 如果c&#x3D;0，w&#x3D;0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</li><li>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</li><li>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</li><li>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</li><li>如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</li></ul><p>tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p><p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p><p>接着是读锁的代码：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">protected final int tryAcquireShared(int unused) &#123;    Thread current &#x3D; Thread.currentThread();    int c &#x3D; getState();    if (exclusiveCount(c) !&#x3D; 0 &amp;&amp;        getExclusiveOwnerThread() !&#x3D; current)        return -1;                                   &#x2F;&#x2F; 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态    int r &#x3D; sharedCount(c);    if (!readerShouldBlock() &amp;&amp;        r &lt; MAX_COUNT &amp;&amp;        compareAndSetState(c, c + SHARED_UNIT)) &#123;        if (r &#x3D;&#x3D; 0) &#123;            firstReader &#x3D; current;            firstReaderHoldCount &#x3D; 1;        &#125; else if (firstReader &#x3D;&#x3D; current) &#123;            firstReaderHoldCount++;        &#125; else &#123;            HoldCounter rh &#x3D; cachedHoldCounter;            if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current))                cachedHoldCounter &#x3D; rh &#x3D; readHolds.get();            else if (rh.count &#x3D;&#x3D; 0)                readHolds.set(rh);            rh.count++;        &#125;        return 1;    &#125;    return fullTryAcquireShared(current);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p><p>此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码：</p><figure><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8b7878ec.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。</p><h2 id="结语">结语</h2><p>本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。</p><p>其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。</p><h2 id="参考资料">参考资料</h2><ol type="1"><li>《Java并发编程艺术》</li><li><a href="https://blog.csdn.net/u013256816/article/details/51204385">Java中的锁</a></li><li><a href="https://juejin.im/post/5a73cbbff265da4e807783f5">Java CAS 原理剖析</a></li><li><a href="https://juejin.im/post/5b42c2546fb9a04f8751eabc">Java并发——关键字synchronized解析</a></li><li><a href="https://zhuanlan.zhihu.com/p/29866981">Java synchronized原理总结</a></li><li><a href="http://www.infoq.com/cn/articles/java-se-16-synchronized">聊聊并发（二）——Java SE1.6中的Synchronized</a></li><li><a href="https://blog.csdn.net/qq_19431333/article/details/70568478">深入理解读写锁—ReadWriteLock源码分析</a></li><li><a href="https://www.cnblogs.com/twoheads/p/9635309.html">【JUC】JDK1.8源码分析之ReentrantReadWriteLock</a></li><li><a href="https://my.oschina.net/adan1/blog/158107">Java多线程（十）之ReentrantReadWriteLock深入分析</a></li><li><a href="https://mrdear.cn/2018/06/23/java/java--readwritelock">Java–读写锁的实现原理</a></li></ol><h1 id="本文转载自">本文转载自</h1><h1 id="不可不说的java锁事---美团技术团队-meituan.com"><a href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java“锁”事 - 美团技术团队 (meituan.com)</a></h1><h2 id="作者简介">作者简介</h2><ul><li>家琪，美团点评后端工程师。2017 年加入美团点评，负责美团点评境内度假的业务开发。</li></ul><p><a href="https://tech.meituan.com/tags/后台.html">后台</a>, <a href="https://tech.meituan.com/tags/美旅技术.html">美旅技术</a>, <a href="https://tech.meituan.com/tags/java.html">Java</a>, <a href="https://tech.meituan.com/tags/锁.html">锁</a></p><p>#看看其他</p><p><a href="https://tech.meituan.com/2018/11/15/reinforcement-learning-in-mt-recommend-system.html">前一篇: 强化学习在美团“猜你喜欢”的实践</a><a href="https://tech.meituan.com/2018/11/22/meituan-brain-nlp-01.html">后一篇: 美团餐饮娱乐知识图谱——美团大脑揭秘</a></p><p>#一起聊聊</p><p>如发现文章有错误、对内容有疑问，都可以关注美团技术团队微信公众号（meituantech），在后台给我们留言。</p><figure><img src="https://p1.meituan.net/travelcube/dc8a757b42b2f6bd12fe8402cc372f041050382.png@1875w_834h_80q" alt="美团技术团队微信二维码"><figcaption aria-hidden="true">美团技术团队微信二维码</figcaption></figure><p>我们每周会挑选出一位热心小伙伴，送上一份精美的小礼品。快来扫码关注我们吧！</p><p>一行代码，亿万生活。</p><ul><li><a href="https://tech.meituan.com/">网站首页</a></li><li><a href="https://tech.meituan.com/archives">文章存档</a></li><li><a href="https://tech.meituan.com/about">关于我们</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;不可不说的java锁事&quot;&gt;&lt;a href=&quot;https://tech.meituan.com/2018/11/15/java-lock.html&quot;&gt;不可不说的Java“锁”事&lt;/a&gt;&lt;/h1&gt;</summary>
    
    
    
    <category term="Java" scheme="https://rds49.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://rds49.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://rds49.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://rds49.github.io/2021/08/23/mysql/mysql/"/>
    <id>https://rds49.github.io/2021/08/23/mysql/mysql/</id>
    <published>2021-08-23T13:27:40.410Z</published>
    <updated>2021-09-06T03:38:27.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引">索引</h1><p>索引原理：将无序的数据转化成有序的查询</p><p>为什么不使用红黑树作为索引？</p><p>因为红黑树是二叉树，数据量大时，高度会很大，比如1亿</p><p>高度越高，比较的次数就越多，这样一来消耗的时间就越多</p><p><strong>hash索引使用少的原因：不支持范围查找</strong></p><h2 id="b树">B+树</h2><figure><img src="/2021/08/23/mysql/mysql/01.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>b+树叶子节点之间是<strong>双向链表</strong>，便于线性查询 比如你要查询20-50 那么你只需要找到20然后线性往后遍历就行，不用找什么父节点之类的</p><h3 id="b树与b树之间的区别"><strong>b树与b+树之间的区别？</strong></h3><p>1.b树的叶子节点之间没有指针,没办法很好的支持范围查找 2.b+树的每个节点都有父节点的索引，相当于冗余索引，这样做的好处是b+树在存储数据时树的高度低     原因：b+树的所有数据的地址指向都存在叶子节点，而b树则是存在对应的层级，因此由于b树虽然没有冗余索引，但是由于b树每一层都要存储数据的地址，因此b+树的高度更低</p><h2 id="联合索引">联合索引</h2><p>联合索引是指对表上的多个列进行索引 <img src="/2021/08/23/mysql/mysql/02.png" alt="img"></p><h3 id="最左前缀原则">最左前缀原则</h3><p>联合索引必须满足的条件 <img src="https://img-blog.csdn.net/20180807153551287?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtMTA2MDg5MTI2NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"> 假定上图联合索引的为（a,b）。联合索引也是一棵B+树，不同的是B+树在对索引a排序的基础上，对索引b排序。所以数据按照（1,1),(1,2)......顺序排放。</p><p>对于selete * from table where a=XX and b=XX，显然是可以使用(a,b)联合索引的，</p><p>对于selete * from table where a=XX，也是可以使用(a,b)联合索引的。因为在这两种情况下，叶子节点中的数据都是有序的。</p><p>但是，对于b列的查询，selete * from table where b=XX。则不可以使用这棵B+树索引。可以发现叶子节点的b值为1,2,1,4,1,2。显然不是有序的，因此不能使用(a,b)联合索引。</p><p>By the way:selete * from table where b=XX and a=XX,也是可以使用到联合索引的，你可能会有疑问，这条语句并不符合最左匹配原则。这是由于查询优化器的存在，mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。所以，当然是我们能尽量的利用到索引时的查询顺序效率最高咯，所以mysql查询优化器会最终以这种顺序进行查询执行。</p><p>优化：在联合索引中将选择性最高的列放在索引最前面。</p><p>例如：在一个公司里以age 和gender为索引，显然age要放在前面，因为性别就两种选择男或女，选择性不如age。</p><h1 id="存储引擎">存储引擎</h1><p>存储引擎是用来修饰表的，不同的表可以使用不同的存储引擎</p><h2 id="myisam">myisam</h2><p>3个文件 frm:存储表的结构 MYD：存储表的数据 MYI：存储表的索引</p><h2 id="innodb">InnoDB</h2><p><strong>为什么建议InnoDB表必须建主件，并且推荐使用整型的自增主件？</strong> 因为InnoDB索引底层使用b+实现，因为索引要保持唯一性，所以当我们使用整型的自增主键时，innoDB就会默认将主键作为索引，如果没有主键，那么mysql就会去找一列不重复的数据作为索引，如果找不到，那么mysql会自己建立一个隐形的字段用于建立索引</p><p><strong>为什么要求</strong> 整型 <strong>，因为查找的时候比较块，要是字符串比较的话，还要求转换成askll码</strong></p><p><strong>为什么要求</strong> 自增 <strong>主键？</strong> 因为自增的话，在插入的时候他永远是在后面插入，这样对于b+树结构的影响小，而非自增的话，他可能会从中间插入，这样对于b+树的结构就影响比较大</p><p>为什么非主键索引结构叶子节点存储的是主键值？ 一致性和节省存储空间</p><p>为了一致性和节省存储空间。已经维护了一套主键索引+数据的B+Tree结构，如果再有其他的非主键索引的话，索引的叶子节点存储的是主键，这是为了节省空间，因为继续存数据的话，那就会导致一份数据存了多份，空间占用就会翻倍。另一方面也是一致性的考虑，都通过主键索引来找到最终的数据，避免维护多份数据导致不一致的情况。</p><p>主键索引和非主键索引维护各自的B+树结构，当插入的数据的时候，由于数据只有一份，通过非主键索引获取到主键值，然后再去主键索引的B+树数据结构中找到对应的行数据，节省了内存空间；</p><p>如果非主键索引的叶子节点也存储一份数据，如果通过非主键索引插入数据，那么要向主键索引对应的行数据进行同步，那么会带来数据一致性问题。可以通过事务的方式解决，我们都知道使用事务后，就会对性能有所消耗。</p><h1 id="mvcc">MVCC</h1><p>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制. 一般在数据库管理系统中，实现对数据库的并发访问。</p><p>在Mysql的InnoDB引擎中就是指在已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)这两种隔离级别下的事务对于SELECT操作会访问版本链中的记录的过程。</p><p>这就使得别的事务可以修改这条记录，反正每次修改都会在版本链中记录。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，提升了系统的性能。 <strong>MVCC模型在MySQL中的具体实现则是由 3个隐式字段，undo日志 ，Read View 等去完成的</strong></p><h2 id="隐式字段">隐式字段</h2><ul><li>DB_TRX_ID 6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</li><li>DB_ROLL_PTR 7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</li><li>DB_ROW_ID 6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li><li>实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了</li></ul><h2 id="版本链update-undo-日志">版本链（update undo 日志）</h2><p><strong>为什么是update日志而不包含insert日志呢？</strong> 对于 Insert Undo Log 来说，它只会用于在事务中发生错误的回滚，因为一旦事务提交了，Insert Undo Log 就完全没用了，所以在事务提交之后 Insert Undo Log 就会被删除。</p><p>而 Update Undo Log 不同，其可以用于 MVCC 的一致性读，为不同版本的请求提供数据源。那这样一来，是不是 Update Undo Log 就完全没法移除了？因为你不清楚啥时候就会有个一致性读请求过来，然后导致其占用的空间越来越大。</p><p>一、 比如一个有个事务插入persion表插入了一条新记录，记录如下，name为Jerry, age为24岁，隐式主键是1，事务ID和回滚指针，我们假设为NULL</p><figure><img src="https:////upload-images.jianshu.io/upload_images/3133209-e52ee5ae248c5a08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/833/format/webp" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>二、 现在来了一个事务1对该记录的name做出了修改，改为Tom</p><ul><li><p>在事务1修改该行(记录)数据时，数据库会先对该行加排他锁</p></li><li><p>然后把该行数据拷贝到undo log中，作为旧记录，既在undo log中有当前行的拷贝副本</p></li><li><p>拷贝完毕后，修改该行name为Tom，并且修改隐藏字段的事务ID为当前事务1的ID, 我们默认从1开始，之后递增，回滚指针指向拷贝到undo log的副本记录，既表示我的上一个版本就是它</p></li><li><p>事务提交后，释放锁</p><figure><img src="https:////upload-images.jianshu.io/upload_images/3133209-3b89396902dbf513.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/843/format/webp" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ul><p>三、 又来了个事务2修改person表的同一个记录，将age修改为30岁</p><ul><li><p>在事务2修改该行数据时，数据库也先为该行加锁</p></li><li><p>然后把该行数据拷贝到undo log中，作为旧记录，发现该行记录已经有undo log了，那么最新的旧数据作为链表的表头，插在该行记录的undo log最前面</p></li><li><p>修改该行age为30岁，并且修改隐藏字段的事务ID为当前事务2的ID, 那就是2，回滚指针指向刚刚拷贝到undo log的副本记录</p></li><li><p>事务提交，释放锁</p><figure><img src="https:////upload-images.jianshu.io/upload_images/3133209-70cdae4621d5543e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/838/format/webp" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></li></ul><p>从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该undo log的节点可能是会purge线程清除掉，向图中的第一条insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）</p><h2 id="readview">ReadView</h2><p>说了版本链我们再来看看ReadView。<strong>已提交读和可重复读的区别就在于它们生成ReadView的策略不同</strong>。</p><p>ReadView中主要就是有个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务。通过这个列表来判断记录的某个版本是否对当前事务可见。假设当前列表里的事务id为[80,100]。</p><ul><li><p>如果你要访问的记录版本的事务id为50，比当前列表最小的id80小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。</p></li><li><p>如果你要访问的记录版本的事务id为90,发现此事务在列表id最大值和最小值之间，那就再判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能被访问。如果不在那说明事务已经提交，所以版本可以被访问。</p></li><li><p>如果你要访问的记录版本的事务id为110，那比事务列表最大id100都大，那说明这个版本是在ReadView生成之后才发生的，所以不能被访问。</p></li></ul><p>这些记录都是去版本链里面找的，先找最近记录，如果最近这一条记录事务id不符合条件，不可见的话，再去找上一个版本再比较当前事务的id和这个版本事务id看能不能访问，以此类推直到返回可见的版本或者结束。</p><p>举个例子 ，在已提交读隔离级别下：</p><p>比如此时有一个事务id为100的事务，修改了name,使得的name等于小明2，但是事务还没提交。则此时的版本链是</p><figure><img src="https://pics1.baidu.com/feed/9213b07eca806538800e900ad4e53940ac3482fb.jpeg?token=dc6d02c5cfee81ea244d58e6d96987e7&amp;s=3DA67C329B3A440902F595D800007031" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>那此时另一个事务发起了select 语句要查询id为1的记录，那此时生成的ReadView 列表只有[100]。那就去版本链去找了，首先肯定找最近的一条，发现trx_id是100,也就是name为小明2的那条记录，发现在列表内，所以不能访问。</p><p>这时候就通过指针继续找下一条，name为小明1的记录，发现trx_id是60，小于列表中的最小id,所以可以访问，直接访问结果为小明1。</p><p>那这时候我们把事务id为100的事务提交了，并且新建了一个事务id为110也修改id为1的记录，并且不提交事务</p><figure><img src="https://pics2.baidu.com/feed/9213b07eca8065385446a462d4e53940ac3482cb.jpeg?token=73df79b1cc511ea7da8d11c32d14537f&amp;s=D3D4C02AC619C821127E34D9020010BB" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>这时候版本链就是</p><figure><img src="https://pics3.baidu.com/feed/7a899e510fb30f24bc54d7ad8bad4947ac4b030a.jpeg?token=ae833396cf2ea773e24e5e9756d8acbc&amp;s=31667C32130F45491E65B0DA0000A031" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>这时候之前那个select事务又执行了一次查询,要查询id为1的记录。</p><p><strong>这个时候关键的地方来了</strong></p><p>如果你是<strong>已提交读隔离级别，这时候你会重新一个ReadView</strong>，那你的活动事务列表中的值就变了，变成了[110]。</p><p>按照上的说法，你去版本链通过trx_id对比查找到合适的结果就是小明2。</p><p>如果你是<strong>可重复读隔离级别，这时候你的ReadView还是第一次select时候生成的ReadView,</strong>也就是列表的值还是[100]。所以select的结果是小明1。所以第二次select结果和第一次一样，所以叫可重复读！</p><p><strong>也就是说已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。</strong></p><p>这就是Mysql的MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过ReadView生成策略的不同实现不同的隔离级别。 # 锁 锁是计算机协调多个进程或线程并发访问某一资源的机制。锁保证数据并发访问的一致性、有效性；锁冲突也是影响数据库并发访问性能的一个重要因素。锁是Mysql在服务器层和存储引擎层的的并发控制。</p><h2 id="锁机制"><strong>锁机制</strong></h2><h2 id="共享锁与排他锁"><strong>共享锁与排他锁</strong></h2><ul><li>共享锁（读锁）：其他事务可以读，但不能写。</li><li>排他锁（写锁） ：其他事务不能读取，也不能写。</li></ul><h2 id="粒度锁"><strong>粒度锁</strong></h2><p>MySQL 不同的存储引擎支持不同的锁机制，所有的存储引擎都以自己的方式显现了锁机制，服务器层完全不了解存储引擎中的锁实现：</p><ul><li>MyISAM 和 MEMORY 存储引擎采用的是表级锁（table-level locking）</li><li>BDB 存储引擎采用的是页面锁（page-level locking），但也支持表级锁</li><li>InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。</li></ul><p>默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。</p><p>但是在有的情况下， 用户需要明确地进行锁表或者进行事务的控制， 以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。</p><h2 id="不同粒度锁的比较"><strong>不同粒度锁的比较：</strong></h2><ul><li><p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p></li><li><ul><li>这些存储引擎通过总是一次性同时获取所有需要的锁以及总是按相同的顺序获取表锁来避免死锁。</li><li>表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用</li></ul></li><li><p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p></li><li><ul><li>最大程度的支持并发，同时也带来了最大的锁开销。</li><li>在 InnoDB 中，除单个 SQL 组成的事务外， 锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。</li><li>行级锁只在存储引擎层实现，而Mysql服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统</li></ul></li><li><p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p></li></ul><h2 id="myisam-表锁"><strong>MyISAM 表锁</strong></h2><h2 id="myisam表级锁模式"><strong>MyISAM表级锁模式：</strong></h2><ul><li>表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li><li>表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；</li></ul><p>MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。 其他线程的读、 写操作都会等待，直到锁被释放为止。</p><p>默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。 （This ensures that updates to a table are not “starved” even when there is heavy SELECT activity for the table. However, if there are many updates for a table, SELECT statements wait until there are no more updates.）。</p><p>这也正是 MyISAM 表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。同时，一些需要长时间运行的查询操作，也会使写线程“饿死” ，应用中应尽量避免出现长时间运行的查询操作（在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解” ，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行）。</p><p>可以设置改变读锁和写锁的优先级：</p><ul><li>通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。</li><li>通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。</li><li>通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。</li><li>给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。</li></ul><h2 id="myisam加表锁方法"><strong>MyISAM加表锁方法：</strong></h2><p>MyISAM 在执行查询语句（SELECT）前，会自动给涉及的表加读锁，在执行更新操作 （UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。</p><p>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，这也正是 MyISAM 表不会出现死锁（Deadlock Free）的原因。</p><p>MyISAM存储引擎支持并发插入，以减少给定表的读和写操作之间的争用：</p><p>如果MyISAM表在数据文件中间没有空闲块，则行始终插入数据文件的末尾。 在这种情况下，你可以自由混合并发使用MyISAM表的INSERT和SELECT语句而不需要加锁——你可以在其他线程进行读操作的时候，同时将行插入到MyISAM表中。 文件中间的空闲块可能是从表格中间删除或更新的行而产生的。 如果文件中间有空闲快，则并发插入会被禁用，但是当所有空闲块都填充有新数据时，它又会自动重新启用。 要控制此行为，可以使用MySQL的concurrent_insert系统变量。</p><p>如果你使用LOCK TABLES显式获取表锁，则可以请求READ LOCAL锁而不是READ锁，以便在锁定表时，其他会话可以使用并发插入。</p><ul><li>当concurrent_insert设置为0时，不允许并发插入。</li><li>当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个线程读表的同时，另一个线程从表尾插入记录。这也是MySQL的默认设置。</li><li>当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。</li></ul><h2 id="查询表级锁争用情况"><strong>查询表级锁争用情况：</strong></h2><p>可以通过检查 table_locks_waited 和 table_locks_immediate 状态变量来分析系统上的表锁的争夺，如果 Table_locks_waited 的值比较高，则说明存在着较严重的表级锁争用情况：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mysql> SHOW STATUS LIKE 'Table%';+-----------------------+---------+| Variable_name | Value |+-----------------------+---------+| Table_locks_immediate | 1151552 || Table_locks_waited | 15324 |+-----------------------+---------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="innodb行级锁和表级锁"><strong>InnoDB行级锁和表级锁</strong></h2><h2 id="innodb锁模式"><strong>InnoDB锁模式：</strong></h2><p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li><li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li></ul><p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li></ul><p><strong>锁模式的兼容情况：</strong></p><figure><img src="https://pic4.zhimg.com/v2-37761612ead11ddc3762a4c20ddab3f3_r.jpg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>（如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务； 反之， 如果两者不兼容，该事务就要等待锁释放。）</p><h2 id="innodb加锁方法"><strong>InnoDB加锁方法：</strong></h2><ul><li><p>意向锁是 InnoDB 自动加的， 不需用户干预。</p></li><li><p>对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB 会自动给涉及数据集加排他锁（X)；</p></li><li><p>对于普通 SELECT 语句，InnoDB 不会加任何锁； 事务可以通过以下语句显式给记录集加共享锁或排他锁：</p></li><li><ul><li>共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</li><li>排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</li></ul></li><li><p><strong>隐式锁定：</strong></p></li></ul><p>InnoDB在事务执行过程中，使用两阶段锁协议：</p><p>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；</p><p>锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在<strong>同一时刻</strong>被释放。</p><ul><li><strong>显式锁定 ：</strong></li></ul><pre class="line-numbers language-text" data-language="text"><code class="language-text">select ... lock in share mode //共享锁 select ... for update //排他锁 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>select for update：</strong></p><p>在执行这个 select 查询语句的时候，会将对应的索引访问条目进行上排他锁（X 锁），也就是说这个语句对应的锁就相当于update带来的效果。</p><p>select *** for update 的使用场景：为了让自己查到的数据确保是最新数据，并且查到后的数据只允许自己来修改的时候，需要用到 for update 子句。</p><p><strong>select lock in share mode ：</strong>in share mode 子句的作用就是将查找到的数据加上一个 share 锁，这个就是表示其他的事务只能对这些数据进行简单的select 操作，并不能够进行 DML 操作。select *** lock in share mode 使用场景：为了确保自己查到的数据没有被其他的事务正在修改，也就是说确保查到的数据是最新的数据，并且不允许其他人来修改数据。但是自己不一定能够修改数据，因为有可能其他的事务也对这些数据 使用了 in share mode 的方式上了 S 锁。</p><p><strong>性能影响：</strong> select for update 语句，相当于一个 update 语句。在业务繁忙的情况下，如果事务没有及时的commit或者rollback 可能会造成其他事务长时间的等待，从而影响数据库的并发使用效率。 select lock in share mode 语句是一个给查找的数据上一个共享锁（S 锁）的功能，它允许其他的事务也对该数据上S锁，但是不能够允许对该数据进行修改。如果不及时的commit 或者rollback 也可能会造成大量的事务等待。</p><p><strong>for update 和 lock in share mode 的区别：</strong></p><p>前一个上的是排他锁（X 锁），一旦一个事务获取了这个锁，其他的事务是没法在这些数据上执行 for update ；后一个是共享锁，多个事务可以同时的对相同数据执行 lock in share mode。</p><h2 id="innodb-行锁实现方式"><strong>InnoDB 行锁实现方式：</strong></h2><ul><li>InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</li><li>不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。</li><li>只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突时， 别忘了检查 SQL 的执行计划（可以通过 explain 检查 SQL 的执行计划），以确认是否真正使用了索引。（更多阅读：<a href="http://mp.weixin.qq.com/s/h4B84UmzAUJ81iBY_FXNOg">MySQL索引总结</a>）</li><li>由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个session是访问不同行的记录， 但是如果是使用相同的索引键， 是会出现锁冲突的（后使用这些索引的session需要等待先使用索引的session释放锁后，才能获取锁）。 应用设计的时候要注意这一点。</li></ul><h2 id="innodb的间隙锁"><strong>InnoDB的间隙锁：</strong></h2><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p><p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p><p><strong>InnoDB使用间隙锁的目的：</strong></p><ol type="1"><li>防止幻读，以满足相关隔离级别的要求；</li><li>满足恢复和复制的需要：</li></ol><p>MySQL 通过 BINLOG 录入执行成功的 INSERT、UPDATE、DELETE 等更新数据的 SQL 语句，并由此实现 MySQL 数据库的恢复和主从复制。MySQL 的恢复机制（复制其实就是在 Slave Mysql 不断做基于 BINLOG 的恢复）有以下特点：</p><p>一是 MySQL 的恢复是 SQL 语句级的，也就是重新执行 BINLOG 中的 SQL 语句。</p><p>二是 MySQL 的 Binlog 是按照事务提交的先后顺序记录的， 恢复也是按这个顺序进行的。</p><p>由此可见，MySQL 的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读。</p><h2 id="innodb-在不同隔离级别下的一致性读及锁的差异"><strong>InnoDB 在不同隔离级别下的一致性读及锁的差异：</strong></h2><p>锁和多版本数据（MVCC）是 InnoDB 实现一致性读和 ISO/ANSI SQL92 隔离级别的手段。</p><p>因此，在不同的隔离级别下，InnoDB 处理 SQL 时采用的一致性读策略和需要的锁是不同的：</p><figure><img src="https://pic2.zhimg.com/v2-c83c6459f8dc93a5f157fe1e3080088d_r.jpg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://pic1.zhimg.com/v2-568951f4cdfeb9416042627a7b94c4ac_r.jpg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>对于许多 SQL，隔离级别越高，InnoDB 给记录集加的锁就越严格（尤其是使用范围条件的时候），产生锁冲突的可能性也就越高，从而对并发性事务处理性能的 影响也就越大。</p><p>因此， 我们在应用中， 应该尽量使用较低的隔离级别， 以减少锁争用的机率。实际上，通过优化事务逻辑，大部分应用使用 Read Commited 隔离级别就足够了。对于一些确实需要更高隔离级别的事务， 可以通过在程序中执行 SET SESSION TRANSACTION ISOLATION</p><p>LEVEL REPEATABLE READ 或 SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE 动态改变隔离级别的方式满足需求。</p><h2 id="获取-innodb-行锁争用情况"><strong>获取 InnoDB 行锁争用情况：</strong></h2><p>可以通过检查 InnoDB_row_lock 状态变量来分析系统上的行锁的争夺情况：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mysql> show status like 'innodb_row_lock%'; +-------------------------------+-------+ | Variable_name | Value | +-------------------------------+-------+ | InnoDB_row_lock_current_waits | 0 | | InnoDB_row_lock_time | 0 | | InnoDB_row_lock_time_avg | 0 | | InnoDB_row_lock_time_max | 0 | | InnoDB_row_lock_waits | 0 | +-------------------------------+-------+ 5 rows in set (0.01 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lock-tables-和-unlock-tables"><strong>LOCK TABLES 和 UNLOCK TABLES</strong></h2><p>Mysql也支持lock tables和unlock tables，这都是在服务器层（MySQL Server层）实现的，和存储引擎无关，它们有自己的用途，并不能替代事务处理。 （除了禁用了autocommint后可以使用，其他情况不建议使用）：</p><ul><li>LOCK TABLES 可以锁定用于当前线程的表。如果表被其他线程锁定，则当前线程会等待，直到可以获取所有锁定为止。</li><li>UNLOCK TABLES 可以释放当前线程获得的任何锁定。当前线程执行另一个 LOCK TABLES 时， 或当与服务器的连接被关闭时，所有由当前线程锁定的表被隐含地解锁</li></ul><h2 id="lock-tables语法"><strong>LOCK TABLES语法：</strong></h2><ul><li>在用 LOCK TABLES 对 InnoDB 表加锁时要注意，要将 AUTOCOMMIT 设为 0，否则MySQL 不会给表加锁；</li><li>事务结束前，不要用 UNLOCK TABLES 释放表锁，因为 UNLOCK TABLES会隐含地提交事务；</li><li>COMMIT 或 ROLLBACK 并不能释放用 LOCK TABLES 加的表级锁，必须用UNLOCK TABLES 释放表锁。</li></ul><p>正确的方式见如下语句： 例如，如果需要写表 t1 并从表 t 读，可以按如下做：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">SET AUTOCOMMIT=0; LOCK TABLES t1 WRITE, t2 READ, ...; [do something with tables t1 and t2 here]; COMMIT; UNLOCK TABLES;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用lock-tables的场景"><strong>使用LOCK TABLES的场景：</strong></h2><p>给表显示加表级锁（InnoDB表和MyISAM都可以），一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。（与MyISAM默认的表锁行为类似）</p><p>在用 LOCK TABLES 给表显式加表锁时，必须同时取得所有涉及到表的锁，并且 MySQL 不支持锁升级。也就是说，在执行 LOCK TABLES 后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。</p><p>其实，在MyISAM自动加锁（表锁）的情况下也大致如此，MyISAM 总是一次获得 SQL 语句所需要的全部锁，这也正是 MyISAM 表不会出现死锁（Deadlock Free）的原因。</p><p>例如，有一个订单表 orders，其中记录有各订单的总金额 total，同时还有一个 订单明细表 order_detail，其中记录有各订单每一产品的金额小计 subtotal，假设我们需要检 查这两个表的金额合计是否相符，可能就需要执行如下两条 SQL：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Select sum(total) from orders; Select sum(subtotal) from order_detail; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这时，如果不先给两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中， order_detail 表可能已经发生了改变。因此，正确的方法应该是：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Lock tables orders read local, order_detail read local; Select sum(total) from orders; Select sum(subtotal) from order_detail; Unlock tables;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（在 LOCK TABLES 时加了“local”选项，其作用就是允许当你持有表的读锁时，其他用户可以在满足 MyISAM 表并发插入条件的情况下，在表尾并发插入记录（MyISAM 存储引擎支持“并发插入”））</p><h2 id="死锁deadlock-free"><strong>死锁（Deadlock Free）</strong></h2><ul><li><p><strong>死锁产生：</strong></p></li><li><ul><li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</li><li>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。</li><li>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</li></ul></li><li><p><strong>检测死锁：</strong>数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p></li><li><p><strong>死锁恢复：</strong>死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p></li><li><p><strong>外部锁的死锁检测：</strong>发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决</p></li><li><p><strong>死锁影响性能：</strong>死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖innodb_lock_wait_timeout设置进行事务回滚。</p></li></ul><h2 id="myisam避免死锁"><strong>MyISAM避免死锁：</strong></h2><ul><li>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。</li></ul><h2 id="innodb避免死锁"><strong>InnoDB避免死锁：</strong></h2><ul><li>为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用SELECT ... FOR UPDATE语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</li><li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</li><li>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</li><li>通过SELECT ... LOCK IN SHARE MODE获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</li><li>改变事务隔离级别</li></ul><p>如果出现死锁，可以用 SHOW INNODB STATUS 命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</p><h2 id="一些优化锁性能的建议"><strong>一些优化锁性能的建议</strong></h2><ul><li>尽量使用较低的隔离级别；</li><li>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会</li><li>选择合理的事务大小，小事务发生锁冲突的几率也更小</li><li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁</li><li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会</li><li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响</li><li>不要申请超过实际需要的锁级别</li><li>除非必须，查询时不要显示加锁。 MySQL的MVCC可以实现事务中的查询不用加锁，优化事务性能；MVCC只在COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作</li><li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能</li></ul><h2 id="乐观锁悲观锁"><strong>乐观锁、悲观锁</strong></h2><ul><li><strong>乐观锁(Optimistic Lock)</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。</li></ul><p>乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p><ul><li><strong>悲观锁(Pessimistic Lock)</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</li></ul><p>悲观锁，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">参考：《高性能MySQL》《深入浅出MySQL》http://www.cnblogs.com/liushuiwuqing/p/3966898.html  https://dev.mysql.com/doc/refman/5.7/en/internal-locking.html http://www.cnblogs.com/0201zcr/p/4782283.html <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="转载">转载</h1><p>非原创，内容基本转载</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;索引&quot;&gt;索引&lt;/h1&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://rds49.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://rds49.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>java面经</title>
    <link href="https://rds49.github.io/2021/08/22/%E9%9D%A2%E7%BB%8F/Java/"/>
    <id>https://rds49.github.io/2021/08/22/%E9%9D%A2%E7%BB%8F/Java/</id>
    <published>2021-08-22T09:35:40.163Z</published>
    <updated>2021-09-03T00:35:46.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="arraylist-扩容的函数方法名是什么">ArrayList 扩容的函数方法名是什么？</h1><p>ensureCapacityInternal(minCapacity);</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount!!</span>    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ensureCapacityInternal(size + 1);就是扩容的函数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token function">calculateCapacity</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里调用了 ensureExplicitCapacity，calculateCapacity</p><p>我们先来看calculateCapacity</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">calculateCapacity</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">,</span> <span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> minCapacity<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（部分变量的具体解释在后面）先判断elementData 是否为空，DEFAULT_CAPACITY为默认容量，默认为10。</p><p>若elementData 为空，那么 Math.max(DEFAULT_CAPACITY, minCapacity)最少为10，</p><p>也就是说集合的初始容量最少也是10；不为空的的时候（肯定执行过空这步，所以也至少为10）</p><p>elementData是用来存储数据的数组，DEFAULTCAPACITY_EMPTY_ELEMENTDATA就是一个<strong>不可改变的空数组</strong>，用来<strong>判断</strong>elementData<strong>是否为null</strong>的（没有看出DEFAULTCAPACITY_EMPTY_ELEMENTDATA有什么其他作用）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>初次初始化时elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */</span><span class="token keyword">transient</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span> <span class="token comment">// non-private to simplify nested class access</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着执行ensureExplicitCapacity</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// overflow-conscious code</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​ modCount++;用来计数的，对扩容没有什么影响，minCapacity大于当前数组的长度才执行grow(minCapacity);</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// overflow-conscious code</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// minCapacity is usually close to size, so this is a win:</span>    elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);这里可以看出，每次扩容扩大的是1.5倍，而不是单纯的加1</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// overflow</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> MAX_ARRAY_SIZE<span class="token punctuation">)</span> <span class="token operator">?</span>        <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span>        MAX_ARRAY_SIZE<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当扩容量（newCapacity）大于ArrayList数组定义的最大值后会调用hugeCapacity来进行判断。如果minCapacity已经大于Integer的最大值（<strong>溢出为负数</strong>）那么抛出OutOfMemoryError（内存溢出）否则的话根据与MAX_ARRAY_SIZE的比较情况确定是返回Integer最大值还是MAX_ARRAY_SIZE。这边也可以看到ArrayList允许的最大容量就是Integer的最大值（-2的31次方~2的31次方减1）。</p><h1 id="juc-的原子类是怎么实现原子性的">JUC 的原子类是怎么实现原子性的</h1><p>JUC ： java.util.concurrent</p><p>使用CAS+volatile实现的</p><h1 id="说下-cas-算法">说下 CAS <a href="https://www.nowcoder.com/jump/super-jump/word?word=算法">算法</a>？</h1><p>CAS是compareAndSet 的简称</p><p><strong>通过无锁的方式解决多线程并发问题。</strong></p><p>比如AtomicInterger</p><p>在调用getAndIncrement时(getAndIncrement相当于++i，一个先赋值后自增的函数)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>this就是当前对象的地址，</p><p>valueOffset存储的是value的地址</p><p>Unsafe 对象不能直接调用，只能通过反射获得</p><pre class="line-numbers language-none"><code class="language-none">private static final long valueOffset;static &#123;    try &#123;        valueOffset &#x3D; unsafe.objectFieldOffset            (AtomicInteger.class.getDeclaredField(&quot;value&quot;));    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;&#125;private volatile int value;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1要加的值</p><p>调用getAndInt</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> var5<span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>        var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> var5<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>getIntVolatile</p><p>native方法</p><p>通过对象地址与value地址获取到对应对象的value,将值给var5</p><p>compareAndSwapInt</p><p>native 方法</p><p>利用 var1 var2获取到value的值，将获取到的值与var5进行比较，它俩一致，就说明当前值没有发生像脏读这样因为多线程数据混乱的情况，因此就可以对当前值进行修改</p><h1 id="为什么无锁效率高">为什么无锁效率高</h1><ul><li>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。打个比喻</li><li>线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速... 恢复到高速运行，代价比较大</li><li>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</li></ul><h1 id="讲讲hash表">讲讲hash表</h1><p>hash表就是散列表，由数组和链表组成，通过hash函数将关键字（非int类型的数据）转换成数组下标</p><h1 id="hash冲突了怎么办">hash冲突了怎么办</h1><p>1.开放地址法 - 线性探测 ：冲突加1 - 再平方探测 ：冲突 　按顺序决定值时，如果某数据的值已经存在，则在原来值的基础上先加1的平方个单位，若仍然存在则减1的平方个单位。随之是2的平方，3的平方等等。直至不发生哈希冲突。 - 伪随机探测 冲突使用随机数 2.链表地址法（散列表） 3.再哈希法 这种方法是同时构造多个不同的哈希函数： Hi=RH1（key） i=1，2，…，k 当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。 4.建立一个公共溢出区 # 如果使用hash进行分布式存储有什么弊端？</p><p>这里相当于考察一致性hash算法 分布式存储就相当于将数据存储在多台机器上 所以弊端就是在增加，减少缓存机器时，会造成缓存失效</p><h1 id="什么时候会gc答gc过程">什么时候会GC？（答GC过程）</h1><p>内存满了就会GC ## 引用计数法 每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计 数为0时可以回收 ## 可达性分析法 从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象。</p><h1 id="你说的majorgc和fullgc有什么区别">你说的MajorGC和fullGC有什么区别？</h1><p>MajorGC指的是老年代GC fullGC指的是年轻代GC+老年代GC</p><h1 id="类锁和对象锁">类锁和对象锁</h1><p>java的内置锁：每个java对象都可以用做一个实现同步的锁，这些锁成为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。</p><p>java内置锁是一个互斥锁，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</p><p>java的对象锁和类锁：java的对象锁和类锁在锁的概念上基本上和内置锁是一致的，但是，两个锁实际是有很大的区别的，对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的</p><p>转载自 https://www.cnblogs.com/owenma/p/8609348.html</p><h1 id="synchorized和lock的区别">synchorized和lock的区别</h1><p>synchorized 是悲观锁，而lock采用的是CAS算法，是乐观锁 <img src="https://img-blog.csdn.net/20180904143958577?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlZmVuZ2xpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><h1 id="内存泄露是什么什么时候会出现内存泄露">内存泄露是什么？什么时候会出现内存泄露？</h1><p>内存泄露：不再会被使用的对象的内存不能被回收，就是内存泄露。</p><p>Java内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。</p><p>静态常量不使用,threadLocal,单例模式</p><h1 id="那你知道磁盘上是如何快速计算当前的容量的吗">那你知道磁盘上是如何快速计算当前的容量的吗？</h1><p>（可以设计一个变量，每次存进去加size，释放就减）你可能对这方面不太了解，其实你可以了解一下，里面是用块存储的，可以用bitmap快速计算容量（我提问：那也会有内存碎片吧）肯定会有，这就是为什么window下会定时进行内存碎片的清除，你可以去了解一下xxx（嗯嗯）</p><h1 id="怎么判断一个java程序存在内存泄漏">怎么判断一个java程序存在内存泄漏 ?</h1><h1 id="cms和g1的区别">CMS和G1的区别 ?</h1><h1 id="g1出现主要是为了优化cms的哪些不足">G1出现主要是为了优化CMS的哪些不足 ?</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;arraylist-扩容的函数方法名是什么&quot;&gt;ArrayList 扩容的函数方法名是什么？&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://rds49.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="Java" scheme="https://rds49.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>哈希冲突</title>
    <link href="https://rds49.github.io/2021/08/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/"/>
    <id>https://rds49.github.io/2021/08/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/</id>
    <published>2021-08-21T12:04:41.350Z</published>
    <updated>2021-09-03T00:50:02.822Z</updated>
    
    <content type="html"><![CDATA[<p>1.开放地址方法</p><p>　　（1）线性探测</p><p>　　　按顺序决定值时，如果某数据的值已经存在，则在原来值的基础上往后加一个单位，直至不发生哈希冲突。　</p><p>　　（2）再平方探测</p><p>　　　按顺序决定值时，如果某数据的值已经存在，则在原来值的基础上先加1的平方个单位，若仍然存在则减1的平方个单位。随之是2的平方，3的平方等等。直至不发生哈希冲突。</p><p>　　（3）伪随机探测</p><p>　　　按顺序决定值时，如果某数据已经存在，通过随机函数随机生成一个数，在原来值的基础上加上随机数，直至不发生哈希冲突。</p><p>2.链式地址法（HashMap的哈希冲突解决方法）</p><p>　　对于相同的值，使用链表进行连接。使用数组存储每一个链表。</p><p>　　优点：</p><p>　　（1）拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；</p><p>　　（2）由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；</p><p>　　（3）开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；</p><p>　　（4）在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。 　　缺点：</p><p>　　指针占用较大空间时，会造成空间浪费，若空间用于增大散列表规模进而提高开放地址法的效率。</p><p>3.建立公共溢出区</p><p>　　建立公共溢出区存储所有哈希冲突的数据。</p><p>4.再哈希法</p><p>　　对于冲突的哈希值再次进行哈希处理，直至没有哈希冲突。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;1.开放地址方法&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://rds49.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://rds49.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>TCP UDP</title>
    <link href="https://rds49.github.io/2021/08/19/TCP%20UDP/"/>
    <id>https://rds49.github.io/2021/08/19/TCP%20UDP/</id>
    <published>2021-08-19T07:39:42.044Z</published>
    <updated>2021-09-03T00:36:09.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcp">TCP</h1><h2 id="三次握手">三次握手</h2><p>换个易于理解的视角来看为什么要3次握手。</p><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是<code>双方都能明确自己和对方的收、发能力是正常的</code>。</p><p><code>第一次握手</code>：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p><code>第二次握手</code>：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p><code>第三次握手</code>：客户端发包，服务端收到了。这样服务端就能得出结论：<strong>客户端的接收、发送能力，服务端的发送、接收能力是正常的</strong>。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><h2 id="四次挥手">四次挥手</h2><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p><p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><p>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</p><p>即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p><p>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</p><p>即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p><p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</p><p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p><p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p><p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p><p>收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;tcp&quot;&gt;TCP&lt;/h1&gt;</summary>
    
    
    
    <category term="Java" scheme="https://rds49.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://rds49.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://rds49.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>双亲委派模型</title>
    <link href="https://rds49.github.io/2021/08/19/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
    <id>https://rds49.github.io/2021/08/19/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-08-19T04:48:15.685Z</published>
    <updated>2021-09-03T00:35:46.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java类加载器">Java类加载器</h2><p>JDK自带有三个类加载器：bootstrap ClassLoader、ExtClassLoader、AppClassLoader。</p><h3 id="启动类加载器">启动类加载器</h3><p>BootStrapClassLoader是ExtClassLoader的父类加载器，默认负责加载%JAVA_HOME%lib下的jar包和 class文件。</p><h3 id="扩展类加载器">扩展类加载器</h3><p>ExtClassLoader是AppClassLoader的父类加载器，负责加载%JAVA_HOME%/lib/ext文件夹下的jar包和 class类。</p><h3 id="应用程序类加载器">应用程序类加载器</h3><p>AppClassLoader是自定义类加载器的父类，负责加载classpath下的类文件。系统类加载器，线程上下 文加载器</p><h3 id="自定义加载器">自定义加载器</h3><p>继承ClassLoader实现自定义类加载器</p><p><img src="/2021/08/19/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/01.png" alt="01" style="zoom:67%;"></p><p>先向上判断是否加载，如果没有加载再向下依次判断是否可以加载</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;java类加载器&quot;&gt;Java类加载器&lt;/h2&gt;</summary>
    
    
    
    <category term="Java" scheme="https://rds49.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://rds49.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://rds49.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rds49.github.io/2021/08/18/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://rds49.github.io/2021/08/18/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-08-18T14:07:19.802Z</published>
    <updated>2021-08-19T04:47:57.617Z</updated>
    
    <content type="html"><![CDATA[<ol type="1"><li><h1 id="jvm-内存模型和各自作用程序计数器jvm虚拟机栈本地方法栈堆方法区哪些是线程私有的程序计数器jvm虚拟机栈本地方法栈">JVM 内存模型和各自作用（程序计数器，JVM虚拟机栈，本地方法栈，堆，方法区），哪些是线程私有的（程序计数器，JVM虚拟机栈，本地方法栈）</h1><img src="https://upload-images.jianshu.io/upload_images/10006199-a4108d8fb7810a71.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp"></li></ol><h2 id="jvm虚拟机栈">JVM虚拟机栈</h2><p>Java每执行一个线程，虚拟机栈就会开辟一部分空间用于程序的执行，一个线程中每有一个方法就会创建一个栈帧。</p><p><strong>栈帧</strong>是一种数据结构:由<strong>局部变量表，操作数栈，动态链接，方法返回地址，附加信息</strong>组成</p><p><img src="/2021/08/18/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/JVM内存模型.png" alt="JVM内存模型" style="zoom: 67%;"></p><h3 id="局部变量表">局部变量表：</h3><p>存储基本数据类型</p><h3 id="操作数栈">操作数栈：</h3><p>存储数据，与局部变量表相结合就可以完成 int a=1的操作</p><p>​ <strong>int a= 1</strong></p><p>JVM的具体操作，先将1存入操作树栈（iconst_1），a存入局部变量表（此时a没有值），1出栈，将1的值赋给a(istore_1)，操作完毕</p><p>局部变量表的下标从0开始，但是0存储的是this,因此其他变量存储都是从1开始</p><h2 id="程序计数器">程序计数器</h2><p>每一个线程都有一个独立的程序计数器。</p><p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看</p><p>做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，</p><p>各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变</p><p>这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、</p><p>线程恢复等基础功能都需要依赖这个计数器来完成。</p><p><img src="/2021/08/18/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/JVM内存模型.png" alt="JVM内存模型" style="zoom: 67%;"></p><p>上图中每一个步骤前面的下标就是程序计数器对应的值</p><p><strong>程序计数器的值是由字节码执行引擎修改的，因为只有字节码执行引擎知道程序执行到了那一步</strong></p><h3 id="java为什么要设计程序计数器">Java为什么要设计程序计数器？</h3><p>java的多线程可能是单核cpu频繁切换线程进行执行的，因此在切换cpu的时候，就要进行线程恢复，那么就必须知道原来的线程执行到那一步了，因此就需要程序计数器来告诉我们</p><h2 id="堆">堆</h2><figure><img src="/2021/08/18/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/JVM内存模型堆.png" alt="JVM内存模型堆"><figcaption aria-hidden="true">JVM内存模型堆</figcaption></figure><p><strong>GC机制在堆中</strong></p><p>存储对象的</p><p>堆本身是二叉树</p><p>A a=new A();</p><p>a存储在栈中，或者说在栈中栈帧的局部变量表内，a中存储的是堆中对应对象的地址</p><p>new A() 就存储在堆中</p><h2 id="方法区">方法区</h2><p>jdk1.8版本之前叫永久代</p><p>方法区中存储<strong>常量，静态变量，类信息</strong></p><p>常量</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>静态变量</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">A</span> a<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类信息</p><p>Math.class字节码文件的信息</p><h2 id="本地方法区">本地方法区</h2><p>存放一些native修饰的方法，其中还有底层的c++代码</p>]]></content>
    
    
    <summary type="html">&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;h1 id=&quot;jvm-内存模型和各自作用程序计数器jvm虚拟机栈本地方法栈堆方法区哪些是线程私有的程序计数器jvm虚拟机栈本地方法栈&quot;&gt;JVM 内存模型和各自作用（程序计数器，JVM虚拟机栈，本地方法栈，堆，方法区），哪些是线程私有的（程序计数器，JVM虚拟机栈，本地方法栈）&lt;/h1&gt;
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10006199-a4108d8fb7810a71.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="https://rds49.github.io/2021/08/17/Spring/Spring/"/>
    <id>https://rds49.github.io/2021/08/17/Spring/Spring/</id>
    <published>2021-08-17T14:20:05.070Z</published>
    <updated>2021-09-03T00:48:34.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ioc">IOC</h1><p>1.IOC思想基与IOC容器完成，IOC的底层就是对象工厂</p><p>2.Spring提供IOC容器实现的两种方式（两个接口）</p><p>​ （1）BeanFactory: IOC容器的基本实现，不提供开发人员使用</p><p>​ （懒加载） 加载配置文件的时候不会创建对象，在获取（使用）对象才去创建对象</p><p>​ （2）ApplicationContext :BeanFactory的子接口，面向开发人员</p><p>​ ApplicationContext 只要一加载配置文件就会创建对象，而不是使用的时候才会去创建</p><h2 id="applicationcontext的两个实现类">ApplicationContext的两个实现类</h2><p>都是读取xml配置文件</p><p>FileSystemXmlApplicationContext 绝对路径</p><p>ClassPathXmlApplicationContext 相对路径</p><h2 id="面试遇到的问题">面试遇到的问题</h2><h3 id="bean可不可以重名">bean可不可以重名</h3><p>答案：在同一个xml文件里不可以重名，在不同的xml文件里可以</p><h1 id="aop">AOP</h1><p>核心思想：在不修改原代码的基础上增加新的功能</p><p>底层原理</p><p>AOP底层使用的是动态代理</p><p>第一种：有接口的情况，使用JDK动态代理</p><p>第二种：没有接口的情况，使用CGLIB动态代理</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ioc&quot;&gt;IOC&lt;/h1&gt;</summary>
    
    
    
    <category term="Java" scheme="https://rds49.github.io/categories/Java/"/>
    
    <category term="Spring" scheme="https://rds49.github.io/categories/Java/Spring/"/>
    
    
    <category term="Spring" scheme="https://rds49.github.io/tags/Spring/"/>
    
    <category term="IOC" scheme="https://rds49.github.io/tags/IOC/"/>
    
    <category term="AOP" scheme="https://rds49.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://rds49.github.io/2021/08/17/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://rds49.github.io/2021/08/17/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-08-17T14:20:05.066Z</published>
    <updated>2021-08-17T14:24:33.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式">单例模式</h1><p><a href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式 | 菜鸟教程 (runoob.com)</a></p><ul><li>1、单例类只能有一个实例。</li><li>2、单例类必须自己创建自己的唯一实例。</li><li>3、<strong>单例类必须给所有其他对象提供这一实例。</strong></li></ul><h2 id="介绍">介绍</h2><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>主要解决：</strong>一个全局使用的类<strong>频繁地创建与销毁</strong>。</p><p><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</p><p><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p><strong>关键代码：</strong>构造函数是私有的。</p><p><strong>应用实例：</strong></p><ul><li>1、一个班级只有一个班主任。</li><li>2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li><li>3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li></ul><p><strong>优点：</strong></p><ul><li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li><li>2、避免对资源的多重占用（比如写文件操作）。</li></ul><p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><h2 id="普通的静态实现">普通的静态实现</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingleObject</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//创建 SingleObject 的一个对象</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">SingleObject</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//让构造函数为 private，这样该类就不会被实例化</span>   <span class="token keyword">private</span> <span class="token class-name">SingleObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">//获取唯一可用的对象</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SingleObject</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> instance<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用它</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonPatternDemo</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">//不合法的构造函数</span>      <span class="token comment">//编译时错误：构造函数 SingleObject() 是不可见的</span>      <span class="token comment">//SingleObject object = new SingleObject();</span>       <span class="token comment">//获取唯一可用的对象</span>      <span class="token class-name">SingleObject</span> object <span class="token operator">=</span> <span class="token class-name">SingleObject</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//显示消息</span>      object<span class="token punctuation">.</span><span class="token function">showMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单例模式的几种实现方式">单例模式的几种实现方式</h2><h3 id="懒汉式线程不安全">1.懒汉式，线程不安全</h3><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>否</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">return</span> instance<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="懒汉式线程安全">2、懒汉式，线程安全</h3><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">return</span> instance<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="饿汉式">3、饿汉式</h3><p><strong>是否 Lazy 初始化：</strong>否</p><p><strong>是否多线程安全：</strong>是</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> instance<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双检锁双重校验锁dcl即-double-checked-locking">4、双检锁/双重校验锁（DCL，即 double-checked locking）</h3><p><strong>JDK 版本：</strong>JDK1.5 起</p><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="登记式静态内部类">5、登记式/静态内部类</h3><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>描述：</strong>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：<strong>第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。</strong>因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token class-name">SingletonHolder</span><span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="枚举">6、枚举</h3><p><strong>JDK 版本：</strong>JDK1.5 起</p><p><strong>是否 Lazy 初始化：</strong>否</p><p><strong>是否多线程安全：</strong>是</p><p><strong>描述：</strong>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。 这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。 不能通过 reflection attack 来调用私有构造方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>      INSTANCE<span class="token punctuation">;</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whateverMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体写法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> EE <span class="token punctuation">&#123;</span>      EE<span class="token punctuation">;</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">kk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> FFFFF <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token class-name">EE</span> e<span class="token operator">=</span>EE<span class="token punctuation">.</span>EE<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">kk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>经验之谈：</strong>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;单例模式&quot;&gt;单例模式&lt;/h1&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://rds49.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="https://rds49.github.io/tags/Java/"/>
    
    <category term="设计模式" scheme="https://rds49.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>GC垃圾回收机制</title>
    <link href="https://rds49.github.io/2021/08/17/GC/"/>
    <id>https://rds49.github.io/2021/08/17/GC/</id>
    <published>2021-08-17T10:06:22.056Z</published>
    <updated>2021-09-03T00:44:35.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gc-垃圾回收机制">gc 垃圾回收机制</h2><h3 id="标记算法">标记算法</h3><p>1：引用计数法</p><p>2：可达性分析法</p><h3 id="垃圾回收算法">垃圾回收算法</h3><h4 id="标记-清除算法mark-and-sweep">1：标记-清除算法（Mark and Sweep）</h4><p>​ 标记存活对象，清除未标记对象（标记标准：可达性分析法）</p><figure><img src="/2021/08/17/GC/GC标记清除.png" alt="GC标记清除"><figcaption aria-hidden="true">GC标记清除</figcaption></figure><p>使用标记清除算法会导致空间碎片化，空间碎片过多，会导致无法找到足够大的连续存储空间</p><p>因此空间碎片过多可能会触发<strong>垃圾收集</strong>工作</p><h4 id="复制算法">2：复制算法</h4><p>解决了标记-清除算法的碎片化问题</p><p>缺点：1.适合对象存活率低的场景（因为要频繁的进行复制，删除）</p><p>​ 2.需要两倍内存</p><p><img src="/2021/08/17/GC/GC复制算法.png" alt="GC复制算法" style="zoom: 33%;"></p><p><img src="/2021/08/17/GC/GC复制算法2.png" alt="GC复制算法2" style="zoom: 33%;"></p><h4 id="标记-整理算法">3：标记-整理算法</h4><figure><img src="/2021/08/17/GC/GC标记-整理算法.png" alt="GC标记-整理算法"><figcaption aria-hidden="true">GC标记-整理算法</figcaption></figure><p>优点：</p><p>​ 避免内存的不连续性（错别字）</p><figure><img src="/2021/08/17/GC/GC标记-整理算法2.png" alt="GC标记-整理算法2"><figcaption aria-hidden="true">GC标记-整理算法2</figcaption></figure><h4 id="分代收集算法">4：分代收集算法</h4><p>​ 相当于前面的整合</p><p><img src="/2021/08/17/GC/GC分代收集算法.png" alt="GC分代收集算法" style="zoom: 50%;"></p><p>eden伊甸园</p><p>jdk6,jdk7有<strong>永久代</strong>（permanent gengeration）</p><p>jdk8以后<strong>没有永久代</strong></p><p><img src="/2021/08/17/GC/Users\Hasee\AppData\Roaming\Typora\typora-user-images\image-20210727204900260.png" alt="image-20210727204900260" style="zoom:50%;"></p><p><strong>年轻代存活率低，采用复制算法</strong></p><p><strong>老年代存活率高，采用标记-清除，或标记-整理算法</strong></p><h5 id="gc的分类">GC的分类</h5><p>Minor GC 年轻代的垃圾回收</p><p>Full GC 老年代的垃圾回收</p><p>Full GC 比 Minor GC 慢，执行效率低很多，一般是10倍</p><h5 id="年轻代尽可能快速收集掉那些生命周期短的对象"><strong>年轻代:尽可能快速收集掉那些生命周期短的对象</strong></h5><p>​ — <strong>eden 区</strong></p><p>​ 绝大部分对象都在eden区中诞生，新生代的对象大部分都是朝生夕死的</p><p>​ 当新建的对象eden区放不下时，对象可能放在Survivor 区或老年区中</p><p>​ — <strong>两个Survivor</strong></p><p>​ —from区</p><p>​ —to区</p><p>​ 或者又称为<strong>S0,S1区</strong> ，S为Survivor简写</p><p>​ from与to 区并不是固定的，有时互相转换</p><figure><img src="/2021/08/17/GC/GC年轻代.png" alt="GC年轻代"><figcaption aria-hidden="true">GC年轻代</figcaption></figure><p><strong>young :1：1：8</strong></p><p><strong>young: old :1:2</strong></p><p>每进行一次Minor GC （年轻代垃圾回收），存储对象的年龄会+1，当对象年龄大于一定数值时（默认是15），对象就会进入老年区</p><h5 id="进入老年区的情况"><strong>进入老年区的情况：</strong></h5><p>1.新建对象内存过大，eden区和survivor区装不下</p><p>2.进行Minor GC 时，eden中的对象要进入S0或S1时S0，S1装不下（eden:S1:S2=8:1:1）,此时进入老年代</p><p>3.年龄大于15</p><p><img src="/2021/08/17/GC/GC晋升老年代.png" alt="GC晋升老年代" style="zoom: 33%;"></p><h5 id="调优">调优</h5><p><img src="/2021/08/17/GC/GC调优参数.png" alt="GC调优参数" style="zoom:50%;"></p><h5 id="触发full-gc的条件">触发Full GC的条件</h5><figure><img src="/2021/08/17/GC/GC触发FullGc.png" alt="GC触发FullGc"><figcaption aria-hidden="true">GC触发FullGc</figcaption></figure><p>永久代空间不足（特指jdk8以前）</p><p>promotion failed: Survivor区 放不下去，同时Old区也放不下去</p><p>concurrent mode failure:CMS 过程中同时有对象要放入Old中，而此时Old中空间不足</p><p>Minor GC晋升到老年代的平均大小大于老年代的剩余空间：执行Minor GC时会统计以前的Minor GC转移到Old区对象占用空间的平均值，如果这个平均值大于Old的剩余空间，执行Full GC</p><p>System.gc() 系统调用GC的命令</p><h3 id="stop-the-world">Stop-the-world</h3><p><img src="/2021/08/17/GC/GC stop World.png" alt="GC stop World" style="zoom: 50%;"></p><h3 id="safepoint-安全点">Safepoint 安全点</h3><p>执行stop-the-world 时，停止其他程序时，不是随随便便就立刻停下来的，必须到达最近的安全点才能停止，这样可以确保程序执行的稳定，突然的停下，会造成一系列的问题</p><p><img src="/2021/08/17/GC/GC安全点.png" alt="GC安全点" style="zoom:33%;"></p><p>安全点太少，稳定性低，太多，增加程序运行的负荷</p><h2 id="常见的垃圾收集器">常见的垃圾收集器</h2><h3 id="jvm的运行模式">JVM的运行模式</h3><p>—Server：启动较慢</p><p>—Client ：启动较快</p><p>​ 进入长期运行之后 Server的运行速度要比Client运行速度要快，因为Server 采用的是重量级的虚拟机，而Client采用的是轻量级的虚拟机</p><p>使用java -version可以查看运行模式</p><h3 id="垃圾收集器之间的联系">垃圾收集器之间的联系</h3><p><img src="/2021/08/17/GC/GC收集器之间的联系.png" alt="GC收集器之间的联系" style="zoom:50%;"></p><p>连线代表可以组合使用</p><h4 id="年轻代的垃圾收集器">年轻代的垃圾收集器</h4><h5 id="serial-收集器-复制算法单线程">Serial 收集器 （复制算法，单线程）</h5><p><strong>单线程</strong></p><p><img src="/2021/08/17/GC/GCserial.png" alt="GCserial" style="zoom: 50%;"></p><h5 id="parnew收集器复制算法多线程">ParNew收集器（复制算法，多线程）</h5><figure><img src="/2021/08/17/GC/GCparNew.png" alt="GCparNew"><figcaption aria-hidden="true">GCparNew</figcaption></figure><h5 id="parallel-scavenge-收集器复制算法">Parallel Scavenge 收集器（复制算法）</h5><p>更关注吞吐量，而不是停顿时间，当然二者相互联系</p><figure><img src="/2021/08/17/GC/GC吞吐量.png" alt="GC吞吐量"><figcaption aria-hidden="true">GC吞吐量</figcaption></figure><figure><img src="/2021/08/17/GC/GCparallel.png" alt="GCparallel"><figcaption aria-hidden="true">GCparallel</figcaption></figure><h4 id="老年代的垃圾收集器">老年代的垃圾收集器</h4><h5 id="serial-old-收集器标记-整理算法">Serial Old 收集器（标记-整理算法）</h5><figure><img src="/2021/08/17/GC/GCserial%20old.png" alt="GCserial old"><figcaption aria-hidden="true">GCserial old</figcaption></figure><h5 id="parallel-old-收集器标记-整理算法jdk6以后">Parallel Old 收集器（标记-整理算法，jdk6以后）</h5><figure><img src="/2021/08/17/GC/GCparallelOld.png" alt="GCparallelOld"><figcaption aria-hidden="true">GCparallelOld</figcaption></figure><h5 id="cms收集器">CMS收集器</h5><figure><img src="/2021/08/17/GC/GC%20CMS收集器.png" alt="GC CMS收集器"><figcaption aria-hidden="true">GC CMS收集器</figcaption></figure><p><strong>初始标记，重新标记需要stop-the-world</strong></p><p>采用的是标记-清除算法 无法避免碎片化问题，只能通过GC处理</p><h4 id="g1收集器年轻代老年代都有">G1收集器(年轻代，老年代都有)</h4><p>Garbage First</p><figure><img src="/2021/08/17/GC/GC%20G1.png" alt="GC G1"><figcaption aria-hidden="true">GC G1</figcaption></figure><figure><img src="/2021/08/17/GC/GC%20G1%202.png" alt="GC G1 2"><figcaption aria-hidden="true">GC G1 2</figcaption></figure><h3 id="强引用软引用弱应用虚引用">强引用，软引用，弱应用，虚引用</h3><figure><img src="/2021/08/17/GC/GC引用.png" alt="GC引用"><figcaption aria-hidden="true">GC引用</figcaption></figure><figure><img src="/2021/08/17/GC/GC%20引用2.png" alt="GC 引用2"><figcaption aria-hidden="true">GC 引用2</figcaption></figure><figure><img src="/2021/08/17/GC/GC%20引用3.png" alt="GC 引用3"><figcaption aria-hidden="true">GC 引用3</figcaption></figure><h3 id="section"></h3>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;gc-垃圾回收机制&quot;&gt;gc 垃圾回收机制&lt;/h2&gt;</summary>
    
    
    
    <category term="Java" scheme="https://rds49.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://rds49.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://rds49.github.io/tags/Java/"/>
    
    <category term="GC" scheme="https://rds49.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>一致性哈希算法</title>
    <link href="https://rds49.github.io/2021/08/16/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    <id>https://rds49.github.io/2021/08/16/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</id>
    <published>2021-08-16T12:24:59.600Z</published>
    <updated>2021-08-16T12:56:28.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一致性哈希算法">一致性哈希算法</h1><p><a href="https://www.bilibili.com/video/BV1Hs411j73w">好刚: 7分钟视频详解一致性hash 算法_哔哩哔哩_bilibili</a></p><h2 id="普通的哈希算法">普通的哈希算法</h2><p>首先我们来介绍一个分布式缓存的例子。</p><p>有3台缓存服务器（<span class="math inline">\(S_0,S_1,S_2\)</span>），有3万张图片要缓存，那么最好的存储方法就是3万张图片均匀的分布在3台缓存服务器上。因为这样可以分担缓存压力</p><p><a href="https://imgtu.com/i/fflxfA"><img src="https://z3.ax1x.com/2021/08/16/fflxfA.png" alt="fflxfA.png"></a></p><p>图片存储服务器的选择通过哈希实现，将图片对应的key的哈希值进行取余，有几台服务器就对几进行取余，</p><p>上例中有3台服务器，那么余数只能为0，1，2分别对应三台服务器。这样就实现了图片在三台缓存服务器上的均匀分布。</p><h3 id="缺陷">缺陷</h3><p>但是这样的算法存在一个致命性的问题，那就是在新增一个服务器的时候，会造成数据的混乱。</p><p>比如在3台缓存服务器的基础上增加1台缓存服务器。那么此时的用于取余的3就变成了4,</p><p>那么比如原来的6，6在只有3台缓存服务器的时候存入</p><p>​ <strong>6 % 3 = 0</strong></p><p>那么6就存于<span class="math inline">\(S_0\)</span>中，此时增加1台缓存服务器，那么读取6对应的数据时就会出现问题</p><p>​ <strong>6 % 4 = 2</strong></p><p>此时就会去<span class="math inline">\(S_2\)</span>上查找数据,是查找不到数据的，就会造成<strong>缓存失效</strong></p><p>这里由于服务器数量的改变------------------&gt;缓存失效----------------------&gt;就会去后端查找数据（因为只是缓存，缓存只是从后端提取出来的）</p><p>由于大量的缓存失效，就会造成缓存雪崩，缓存机制无法起到承担缓存压力的作用，压力就转移到后端服务器，整个系统就容易被压垮，为了避免这个问题就需要使用<strong>一致性哈希算法</strong></p><h2 id="一致性哈希算法-1">一致性哈希算法</h2><p><a href="https://imgtu.com/i/ff1GtJ"><img src="https://z3.ax1x.com/2021/08/16/ff1GtJ.png" alt="ff1GtJ.png"></a></p><p>想象有一个圆，圆上有<span class="math inline">\(2^{32}\)</span>个点，这个环被称为hash环</p><p><a href="https://imgtu.com/i/ff1Jh9"><img src="https://z3.ax1x.com/2021/08/16/ff1Jh9.png" alt="ff1Jh9.png"></a></p><p>在这个环上我们用于取余的数固定为<span class="math inline">\(2^{32}\)</span></p><p>例如有A,B,C三台服务器</p><p>首先利用</p><p>​ hash(A)%<span class="math inline">\(2^{32}\)</span>=服务器A在hash环上的位置</p><p>B,C同理</p><p>接着计算</p><p>​ hash(a.jpg)%<span class="math inline">\(2^{32}\)</span>将图片a.jpg放置在hash环上，延顺时针所遇到的第一台服务器就是a.jpg应存储的服务器</p><p><strong>那么这么做的好处是什么呢？</strong></p><p>此时我们在环上增加一个缓存服务器D，我们发现依然会造成缓存失效，但是只有C--&gt;D的这部分原本存储在A上的缓存失效，这部分缓存现在再获取的时候程序就会去D上获取（定位错误导致获取不到转而去后端获取），造成了C--&gt;D的这部分缓存 缓存失效，但是并没有影响其他的缓存。</p><p><strong>与原来的哈希算法相比，一致性哈希算法再缓存服务器数量发生变化时，只有部分缓存失效，而原来的算法可以说是全部失效</strong></p><p><strong>因此一致性哈希算法可以避免所有的压力同一时间集中在后端的服务器上，因为只有部分缓存失效，其他的有效缓存依然可以分担压力</strong></p><p>但是一致性哈希算法存在一个问题，也就是接下来的hash偏斜</p><h3 id="hash偏斜">hash偏斜</h3><p>在上文的一致性哈希算法介绍时，我们理想化的认为服务器A,B,C均匀的分布在hash环上，但是实际上很有可能会出现下图的情况</p><p><img src="https://z3.ax1x.com/2021/08/16/ff18k4.png" alt="ff18k4.png" style="zoom:33%;"></p><p>A，B，C的分布会偏斜，这种情况称为<strong>hash环的偏斜</strong></p><p>hash环偏斜的情况下大部分的缓存就会存储到同一台服务器上，如下图</p><p>​ <a href="https://imgtu.com/i/fflTQx"><img src="https://z3.ax1x.com/2021/08/16/fflTQx.png" alt="fflTQx.png"></a></p><p>大部分的缓存就会存储到A上，这样就违背了缓存服务器均匀分担压力的初衷</p><p><strong>在这种缓存分布不均匀的情况下，如果占据缓存较多的服务器发生故障，例如缓存失效，这样后端的压力就会增大，就有可能造成系统崩溃</strong></p><p>为了使缓存服务器均匀的分布在hash环上，我们就要使服务器尽可能的多（这样占据的就多，环就会相对均匀），但是服务器就那么几个，因此我们需要引入<strong>虚拟节点</strong>的概念</p><p>例如A可以衍生出多个虚拟节点<span class="math inline">\(A_1,A_2,...,A_n\)</span>使其分布于hash环上</p><p><a href="https://imgtu.com/i/ff117F"><img src="https://z3.ax1x.com/2021/08/16/ff117F.png" alt="ff117F.png"></a></p><p>虚拟节点越多，hash偏斜的影响就越小，</p><p><strong>在具体读写时，先找到虚拟节点，再通过虚拟节点找到真实节点，再进行读写的处理</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一致性哈希算法&quot;&gt;一致性哈希算法&lt;/h1&gt;</summary>
    
    
    
    <category term="算法" scheme="https://rds49.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="https://rds49.github.io/tags/Java/"/>
    
    <category term="算法" scheme="https://rds49.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://rds49.github.io/2021/08/15/%E6%8E%92%E5%BA%8F/"/>
    <id>https://rds49.github.io/2021/08/15/%E6%8E%92%E5%BA%8F/</id>
    <published>2021-08-15T08:02:15.181Z</published>
    <updated>2021-08-18T07:27:29.626Z</updated>
    
    <content type="html"><![CDATA[<h4 id="排序数组"><a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a></h4><h4 id="前言">前言</h4><p>本题你可以选择直接调用库函数来对序列进行排序，但意义不大。由于排序算法有很多，本文只介绍三种常见的基于比较的复杂度较低的排序。</p><h4 id="方法1快速排序">方法1：快速排序</h4><p><strong>思路和算法</strong></p><p>快速排序的主要思想是通过划分将待排序的序列分成前后两部分，其中前一部分的数据都比后一部分的数据要小，然后再递归调用函数对两部分的序列分别进行快速排序，以此使整个序列达到有序。</p><p>我们定义函数 <code>randomized_quicksort(nums, l, r)</code> 为对 <code>nums</code> 数组里 <span class="math inline">\([l,r]\)</span> 的部分进行排序，每次先调用 <code>randomized_partition</code> 函数对 <code>nums</code> 数组里 <span class="math inline">\([l,r]\)</span> 的部分进行划分，并返回分界值的下标 <code>pos</code>，然后按上述将的递归调用 <code>randomized_quicksort(nums, l, pos - 1)</code> 和 <code>randomized_quicksort(nums, pos + 1, r)</code> 即可。</p><p>那么核心就是划分函数的实现了，划分函数一开始需要确定一个分界值（我们称之为主元 <code>pivot</code>)，然后再进行划分。而主元的选取有很多种方式，这里我们采用随机的方式，对当前划分区间 <span class="math inline">\([l,r]\)</span> 里的数等概率随机一个作为我们的主元，再将主元放到区间末尾，进行划分。</p><p>整个划分函数 <code>partition</code> 主要涉及两个指针 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span>，一开始 <code>i = l - 1</code>，<code>j = l</code>。我们需要实时维护两个指针使得任意时候，对于任意数组下标 <span class="math inline">\(k\)</span>，我们有如下条件成立： 1. <span class="math inline">\(l\leq k\leq i\)</span> 时，<span class="math inline">\(\textit{nums}[k]\leq \textit{pivot}\)</span>。</p><ol start="2" type="1"><li><p><span class="math inline">\(i+1\leq k\leq j-1\)</span> 时，<span class="math inline">\(\textit{nums}[k]&gt; \textit{pivot}\)</span>。</p></li><li><p><span class="math inline">\(k==r\)</span> 时，<span class="math inline">\(\textit{nums}[k]=\textit{pivot}\)</span>。</p></li></ol><p>我们每次移动指针 <span class="math inline">\(j\)</span> ，如果 <span class="math inline">\(\textit{nums}[j]&gt; pivot\)</span>，我们只需要继续移动指针 <span class="math inline">\(j\)</span> ，即能使上述三个条件成立，否则我们需要将指针 <span class="math inline">\(i\)</span> 加一，然后交换 <span class="math inline">\(\textit{nums}[i]\)</span> 和 <span class="math inline">\(\textit{nums}[j]\)</span>，再移动指针 <span class="math inline">\(j\)</span> 才能使得三个条件成立。</p><p>当 <span class="math inline">\(j\)</span> 移动到 <span class="math inline">\(r-1\)</span> 时结束循环，此时我们可以由上述三个条件知道 <span class="math inline">\([l,i]\)</span> 的数都小于等于主元 <code>pivot</code>，<span class="math inline">\([i+1,r-1]\)</span> 的数都大于主元 <code>pivot</code>，那么我们只要交换 <span class="math inline">\(\textit{nums}[i+1]\)</span> 和 <span class="math inline">\(\textit{nums}[r]\)</span> ，即能使得 <span class="math inline">\([l,i+1]\)</span> 区间的数都小于 <span class="math inline">\([i+2,r]\)</span> 区间的数，完成一次划分，且分界值下标为 <span class="math inline">\(i+1\)</span>，返回即可。</p><p>如下的动图展示了一次划分的过程，刚开始随机选了 <span class="math inline">\(4\)</span> 作为主元，与末尾元素交换后开始划分：</p><p><img src="https://assets.leetcode-cn.com/solution-static/912/912_fig1.gif" alt="fig1"> <img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fs9.sinaimg.cn%2Fmw690%2F005XMKN4zy7fNR2wI6k78%26690&amp;refer=http%3A%2F%2Fs9.sinaimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1631690928&amp;t=e8b3eb4654be5f50cbdeb480f4572cd2" alt="图片不显示"> ##### 自己的初次写法</p><p>几个要点</p><ul><li>由于结尾处要递归，所以要在开头保存 start,end 的值</li><li>右指针一直递归与左指针重合时应该跳出循环，不然继续操作会将造成赋值错误，左指针递归同理</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">quick</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token keyword">int</span> s<span class="token operator">=</span>start<span class="token punctuation">;</span>          <span class="token keyword">int</span> e<span class="token operator">=</span>end<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token operator">>=</span>end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span>nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>start<span class="token operator">&lt;</span>end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token operator">></span>pivot <span class="token operator">&amp;&amp;</span> end<span class="token operator">></span>start<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                end<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token operator">==</span>end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>            start<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token operator">&lt;</span>pivot <span class="token operator">&amp;&amp;</span> end<span class="token operator">></span>start<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                start<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token operator">==</span>end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>            end<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token operator">=</span>pivot<span class="token punctuation">;</span>        <span class="token function">quick</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>s<span class="token punctuation">,</span>start<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quick</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>start<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">quick</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>快速排序的核心就是比pivot 小的位于左边，大的位于右边，不一定要采用双指针的方法实现</strong></p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> l<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以采用双集合1个存小的，一个存大的，最后合并</p><pre class="line-numbers language-Java" data-language="Java"><div class="caption"><span>[sol1-Java]</span></div><code class="language-Java">class Solution &#123;    public int[] sortArray(int[] nums) &#123;        randomizedQuicksort(nums, 0, nums.length - 1);        return nums;    &#125;    public void randomizedQuicksort(int[] nums, int l, int r) &#123;        if (l &lt; r) &#123;            int pos &#x3D; randomizedPartition(nums, l, r);            randomizedQuicksort(nums, l, pos - 1);            randomizedQuicksort(nums, pos + 1, r);        &#125;    &#125;    public int randomizedPartition(int[] nums, int l, int r) &#123;        int i &#x3D; new Random().nextInt(r - l + 1) + l; &#x2F;&#x2F; 随机选一个作为我们的主元        swap(nums, r, i);&#x2F;&#x2F;这里交换的原因是确保随机取的值位于尾部，便于使用，不然还要传一个随机取的值的下标        return partition(nums, l, r);    &#125;    public int partition(int[] nums, int l, int r) &#123;        int pivot &#x3D; nums[r];        int i &#x3D; l - 1;        for (int j &#x3D; l; j &lt;&#x3D; r - 1; ++j) &#123;            if (nums[j] &lt;&#x3D; pivot) &#123;                i &#x3D; i + 1;                swap(nums, i, j);            &#125;        &#125;        swap(nums, i + 1, r);        return i + 1;    &#125;    private void swap(int[] nums, int i, int j) &#123;        int temp &#x3D; nums[i];        nums[i] &#x3D; nums[j];        nums[j] &#x3D; temp;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：基于随机选取主元的快速排序时间复杂度为期望 <span class="math inline">\(O(n\log n)\)</span>，其中 <span class="math inline">\(n\)</span> 为数组的长度。详细证明过程可以见《算法导论》第七章，这里不再大篇幅赘述。</p></li><li><p>空间复杂度：<span class="math inline">\(O(h)\)</span>，其中 <span class="math inline">\(h\)</span> 为快速排序递归调用的层数。我们需要额外的 <span class="math inline">\(O(h)\)</span> 的递归调用的栈空间，由于划分的结果不同导致了快速排序递归调用的层数也会不同，最坏情况下需 <span class="math inline">\(O(n)\)</span> 的空间，最优情况下每次都平衡，此时整个递归树高度为 <span class="math inline">\(\log n\)</span>，空间复杂度为 <span class="math inline">\(O(\log n)\)</span>。</p></li></ul><h4 id="方法2堆排序">方法2：堆排序</h4><p><strong>最难懂的排序</strong></p><p>说堆排序之前，我们先简单了解一些什么是堆？堆这种数据结构应用场景非常多，所以我们需要熟练掌握呀！</p><p>那我们了解堆之前，先来简单了解下，什么是完全二叉树？</p><p>我们来看下百度百科的定义，完全二叉树：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。</p><p>哦！我们可以这样理解，除了最后一层，其他层的节点个数都是满的，而且最后一层的叶子节点必须靠左。</p><p>下面我们来看一下这几个例子</p><p><img src="https://pic.leetcode-cn.com/1615943042-JdfDdH-%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210316124303.1lo4nr3xhrwg.jpg"></p><p>上面的几个例子中，（1）（4）为完全二叉树，（2）（3）不是完全二叉树，因为他们不满足最后一层叶子节点必须靠左。通过上面的几个例子，我们了解了什么是完全二叉树，</p><p>那么堆到底是什么呢？</p><p>下面我们来看一下二叉堆的要求</p><p>（1）必须是完全二叉树</p><p>（2）二叉堆中的每一个节点，都必须大于等于（或小于等于）其子树中每个节点的值。</p><p>若是每个节点大于等于子树中的每个节点，我们称之为大顶堆，小于等于子树中的每个节点，我们则称之为小顶堆。见下图</p><p>下面我们再来看一下二叉堆的具体例子。</p><figure><img src="https://pic.leetcode-cn.com/1615870575-jzFXqL-file_1615870575029" alt="堆"><figcaption aria-hidden="true">堆</figcaption></figure><p>上图则为大顶堆和小顶堆，我们再来回顾一下堆的要求，看下是否符合（1）必须是完全二叉树（2）堆中的每一个节点，都必须大于等于（或小于等于）其子树中每个节点的值。</p><p>好啦，到这里我们已经完全掌握二叉堆了，那么二叉堆又是怎么存储的呢？因为堆是完全二叉树，所以我们完全可以用数组存储。具体思想见下图，我们仅仅按照顺序将节点存入数组即可，我们通过小顶堆进行演示。</p><p>注：我们是从下标 1 开始存储的，这样能省略一些计算，下文中我们将二叉堆简称为堆</p><p><img src="https://pic.leetcode-cn.com/1615870575-Ubyzzb-file_1615870575038"></p><p>我们来看一下为什么我们可以用数组来存储堆呢？</p><p>我们首先看根节点，也就是值为 1 的节点，它在数组中的下标为 1 ,它的左子节点，也就是值为 4 的节点，此时索引为 2，右子节点也就是值为 2 的节点，它的索引为 3。</p><p>我们发现其中的关系了吗？</p><p>数组中，某节点（非叶子节点）的下标为 i , 那么其**左子节点下标为 2*i<strong> （这里可以直接通过相乘得到左孩子，如果从0 开始存，需要 2<em>i+1 才行）, 右子节点为 2</em>i+1</strong>，<strong>其父节点为 i/2 。既然我们完全可以根据索引找到某节点的 </strong>左子节点<strong> 和 </strong>右子节点**，那么我们用数组存储是完全没有问题的。</p><p>好啦，我们知道了什么是堆和如何用数组存储堆，那我们如何完成堆排序呢？</p><p>堆排序其实主要有两个步骤</p><ul><li>建堆</li><li>排序</li></ul><p>下面我们先来了解下建堆</p><p>我们刚才说了用数组来存储大顶（小顶）堆，此时的元素已经满足某节点大于等于（或小于等于）子树节点，但是随机给我们一个数组，此时并不一定满足上诉要求，所以我们需要调整数组，使其满足大顶堆或小顶堆的要求。这个就是堆化，也可以称其为建堆。</p><p>建堆我们这里提出两种方法，利用上浮操作，也就是不断插入元素进行建堆，另一种是利用下沉操作，遍历父节点，不断将其下沉，进行建堆，我们一起来看吧。</p><p>我们先来说下第一种建堆方式</p><p><strong>利用上浮操作建堆</strong></p><p>说之前我们先来了解下，如何往已经建好的堆里，插入新的元素，我们直接看例子吧，一下就懂啦。</p><figure><img src="https://pic.leetcode-cn.com/1615870575-cprbCy-file_1615870575040" alt="插入元素"><figcaption aria-hidden="true">插入元素</figcaption></figure><p>假设让我们插入新的元素 1 （绿色节点），我们发现此时 1 小于其父节点 的值 7 ，并不遵守小顶堆的规则，那我们则需要移动元素 1 。让 1 与 7 交换，（如果新插入元素大于父节点的值，则说明插入新节点后仍满足小顶堆规则，无需交换）。</p><p>之前我们说过，我们可以用数组保存堆，并且可以通过 i/2 得到其父节点的值，那么此时我们就明白怎么做啦。</p><figure><img src="https://pic.leetcode-cn.com/1615870575-ZGtgRp-file_1615870575042" alt="插入元素"><figcaption aria-hidden="true">插入元素</figcaption></figure><p>将插入节点与其父节点，交换。</p><figure><img src="https://pic.leetcode-cn.com/1615870575-zVTnIf-file_1615870575043" alt="插入元素"><figcaption aria-hidden="true">插入元素</figcaption></figure><p>交换之后，我们继续将新插入元素，也就是 1 与其父节点比较，如果大于其父节点，则无需交换，循环结束。若小于则需要继续交换，直到 1 到达适合他的地方。</p><p><strong>我们发现，我们新插入的元素是不是一层层的上浮，直到找到属于自己的位置，我们将这个操作称之为上浮操作。</strong></p><p>那我们知道了上浮，岂不是就可以实现建堆了？是的，我们则可以依次遍历数组，就好比不断往堆中插入新元素，直至遍历结束，这样我们就完成了建堆，这种方法当然是可以的。</p><p>我们一起来看一下上浮操作代码。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> swim <span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>index<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>index<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//交换</span>        index <span class="token operator">=</span> index<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>既然利用上浮操作建堆已经搞懂啦，那么我们再来了解一下，利用下沉操作建堆吧，也很容易理解。</p><p>给我们一个无序数组（不满足堆的要求），见下图</p><p><img src="https://pic.leetcode-cn.com/1615870575-lTzBSQ-file_1615870575044"></p><p>我们发现，7 位于堆顶，但是此时并不满足小顶堆的要求，我们需要把 7 放到属于它的位置，我们应该怎么做呢？</p><p>废话不多说，我们先来看视频模拟，看完保准可以懂</p><figure><img src="/2021/08/15/%E6%8E%92%E5%BA%8F/0dfa41b0-7364-4ac5-8f4b-cc13d12d4c2e" alt="堆排序下沉.mp4"><figcaption aria-hidden="true">堆排序下沉.mp4</figcaption></figure><p>看完视频是不是懂个大概了，但是不知道大家有没有注意到这个地方。为什么 7 第一次与其左孩子节点 2 交换，第二次与右孩子节点 3 交换。见下图</p><p><img src="https://pic.leetcode-cn.com/1615870575-cJSWaD-file_1615870575045"></p><p>其实很容易理解，我们需要与孩子节点中最小的那个交换，因为我们需要交换后，父节点小于两个孩子节点，如果我们第一步，7 与 5 进行交换的话，则同样不能满足小顶堆。</p><p>那我们怎么判断节点找到属于它的位置了呢？主要有两个情况</p><ul><li>待下沉元素小于（大于）两个子节点，此时符合堆的规则，无序下沉，例如上图中的 6</li><li>下沉为叶子节点，此时没有子节点，例如 7 下沉到最后变成了叶子节点。</li></ul><p>我们将上面的操作称之为下沉操作。</p><p>这时我们又有疑问了，下沉操作我懂了，但是这跟建堆有个锤子关系啊！</p><p>好啦我们一起看哈下沉操作的代码吧。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> sink <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//获取子节点</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> index<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> len<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//交换操作，父节点下沉，与最大的孩子节点交换</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>index<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>             <span class="token comment">//继续下沉</span>            index <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好啦，两种建堆方式我们都已经了解啦，那么我们如何进行排序呢？</p><p>了解排序之前我们先来，看一下如何删除堆顶元素，我们需要保证的是，删除堆顶元素后，其他元素仍能满足堆的要求，我们思考一下如何实现呢？见下图</p><p><img src="https://pic.leetcode-cn.com/1615870575-qLZlOo-file_1615870575046"></p><p>假设我们想要去除堆顶的 11 ，那我们则需要将其与堆的最后一个节点交换也就是 2 ，2然后再执行下沉操作，执行完毕后仍能满足堆的要求，见下图</p><p><img src="https://pic.leetcode-cn.com/1615870575-PhbiFI-file_1615870575047"></p><p>好啦，大家是不是已经搞懂啦，下面我们总结一下堆排序的具体执行过程</p><p>1.建堆，通过下沉操作建堆效率更高，具体过程是，找到最后一个非叶子节点，然后从后往前遍历执行下沉操作。</p><p>2.排序，将堆顶元素（代表最大元素）与最后一个元素交换，然后新的堆顶元素进行下沉操作，遍历执行上诉操作，则可以完成排序。</p><p>好啦，下面我们一起看代码吧</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                  <span class="token comment">//下沉建堆</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">sink</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>i<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> len<span class="token punctuation">;</span>        <span class="token comment">//排序</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>k<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sink</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> sink <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//下沉</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>            <span class="token comment">//找出子节点中最大或最小的那个</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> end <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            k <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> swap <span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注意点">注意点</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">sink</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>i<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>解释一下为什么这里只对一半的数据进行下沉操作，因为通过二叉树的性质可以很容易知道一半的数据已经占据了二叉树除最后一层以外的所有数据也就相当于n层的二叉树已经确定了n<span class="token operator">-</span><span class="token number">1</span>层的数据，所以剩下的最后一层自然而然会满足条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好啦，堆排序我们就到这里啦，是不是搞定啦，总的来说堆排序比其他排序算法稍微难理解一些，重点就是建堆，而且应用比较广泛，大家记得打卡呀。</p><p>好啦，我们再来分析一下堆排序的时间复杂度、空间复杂度以及稳定性。</p><p><strong>堆排序时间复杂度分析</strong></p><p>因为我们建堆的时间复杂度为 O(n），排序过程的时间复杂度为 O(nlogn),所以总的时间复杂度为 O(nlogn)</p><p><strong>堆排序空间复杂度分析</strong></p><p>这里需要注意，我们上面的描述过程中，为了更直观的描述，空出数组的第一位，这样我们就可以通过 i * 2 和 i * 2+1 来求得左孩子节点和右孩子节点 。我们也可以根据 i * 2 + 1 和 i * 2 + 2 来获取孩子节点，这样则不需要临时数组来处理原数组，将所有元素后移一位，所以堆排序的空间复杂度为 O(1),是原地排序算法。</p><p><strong>堆排序稳定性分析</strong></p><p>堆排序不是稳定的排序算法，在排序的过程，我们会将堆的最后一个节点跟堆顶节点交换，改变相同元素的原始相对位置。</p><p>最后我们来比较一下我们快速排序和堆排序</p><p>1.对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。这样对 CPU 缓存是不友好的</p><p>2.相同的的数据，排序过程中，堆排序的数据交换次数要多于快速排序。</p><p>所以上面两条也就说明了在实际开发中，堆排序的性能不如快速排序性能好。</p><h5 id="本人写法">本人写法</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">createHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> heap<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> heap<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">sink</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> i<span class="token punctuation">,</span> heap<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> heap<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heap<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> index<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> len <span class="token operator">&amp;&amp;</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> heap<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> len <span class="token operator">&amp;&amp;</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> heap<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> i<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                index <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> swap <span class="token punctuation">(</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heap<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sortArray <span class="token punctuation">(</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> nums<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heap <span class="token operator">=</span> <span class="token function">createHeap</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> heap<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> heap<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>                len<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token function">sink</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> heap<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> nums<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> main <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token class-name">Solution</span> solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ints <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">sortArray</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> ele <span class="token operator">:</span> ints            <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="官方写法">官方写法</h5><pre class="line-numbers language-Java" data-language="Java"><div class="caption"><span>[sol2-Java]</span></div><code class="language-Java">class Solution &#123;    public int[] sortArray(int[] nums) &#123;        heapSort(nums);        return nums;    &#125;    public void heapSort(int[] nums) &#123;        int len &#x3D; nums.length - 1;        buildMaxHeap(nums, len);        for (int i &#x3D; len; i &gt;&#x3D; 1; --i) &#123;            swap(nums, i, 0);            len -&#x3D; 1;            maxHeapify(nums, 0, len);        &#125;    &#125;    public void buildMaxHeap(int[] nums, int len) &#123;        for (int i &#x3D; len &#x2F; 2; i &gt;&#x3D; 0; --i) &#123;            maxHeapify(nums, i, len);        &#125;    &#125;    public void maxHeapify(int[] nums, int i, int len) &#123;        for (; (i &lt;&lt; 1) + 1 &lt;&#x3D; len;) &#123;            int lson &#x3D; (i &lt;&lt; 1) + 1;            int rson &#x3D; (i &lt;&lt; 1) + 2;            int large;            if (lson &lt;&#x3D; len &amp;&amp; nums[lson] &gt; nums[i]) &#123;                large &#x3D; lson;            &#125; else &#123;                large &#x3D; i;            &#125;            if (rson &lt;&#x3D; len &amp;&amp; nums[rson] &gt; nums[large]) &#123;                large &#x3D; rson;            &#125;            if (large !&#x3D; i) &#123;                swap(nums, i, large);                i &#x3D; large;            &#125; else &#123;                break;            &#125;        &#125;    &#125;    private void swap(int[] nums, int i, int j) &#123;        int temp &#x3D; nums[i];        nums[i] &#x3D; nums[j];        nums[j] &#x3D; temp;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<span class="math inline">\(O(n\log n)\)</span>。初始化建堆的时间复杂度为 <span class="math inline">\(O(n)\)</span>，建完堆以后需要进行 <span class="math inline">\(n-1\)</span> 次调整，一次调整（即 <code>maxHeapify</code>） 的时间复杂度为 <span class="math inline">\(O(\log n)\)</span>，那么 <span class="math inline">\(n-1\)</span> 次调整即需要 <span class="math inline">\(O(n\log n)\)</span> 的时间复杂度。因此，总时间复杂度为 <span class="math inline">\(O(n+n\log n)=O(n\log n)\)</span>。</p></li><li><p>空间复杂度：<span class="math inline">\(O(1)\)</span>。只需要常数的空间存放若干变量。</p></li></ul><h4 id="方法3归并排序">方法3：归并排序</h4><p><strong>思路</strong></p><p>归并排序利用了分治的思想来对序列进行排序。对一个长为 <span class="math inline">\(n\)</span> 的待排序的序列，我们将其分解成两个长度为 <span class="math inline">\(\frac{n}{2}\)</span> 的子序列。每次先递归调用函数使两个子序列有序，然后我们再线性合并两个有序的子序列使整个序列有序。</p><p><strong>算法</strong></p><p>定义 <code>mergeSort(nums, l, r)</code> 函数表示对 <code>nums</code> 数组里 <span class="math inline">\([l,r]\)</span> 的部分进行排序，整个函数流程如下：</p><ol type="1"><li><p>递归调用函数 <code>mergeSort(nums, l, mid)</code> 对 <code>nums</code> 数组里 <span class="math inline">\([l,\textit{mid}]\)</span> 部分进行排序。</p></li><li><p>递归调用函数 <code>mergeSort(nums, mid + 1, r)</code> 对 <code>nums</code> 数组里 <span class="math inline">\([\textit{mid}+1,r]\)</span> 部分进行排序。</p></li><li><p>此时 <code>nums</code> 数组里 <span class="math inline">\([l,\textit{mid}]\)</span> 和 <span class="math inline">\([\textit{mid}+1,r]\)</span> 两个区间已经有序，我们对两个有序区间线性归并即可使 <code>nums</code> 数组里 <span class="math inline">\([l,r]\)</span> 的部分有序。</p><p>线性归并的过程并不难理解，由于两个区间均有序，所以我们维护两个指针 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 表示当前考虑到 <span class="math inline">\([l,\textit{mid}]\)</span> 里的第 <span class="math inline">\(i\)</span> 个位置和 <span class="math inline">\([\textit{mid}+1,r]\)</span> 的第 <span class="math inline">\(j\)</span> 个位置。</p><p>如果 <code>nums[i] &lt;= nums[j]</code> ，那么我们就将 <span class="math inline">\(\textit{nums}[i]\)</span> 放入临时数组 <code>tmp</code> 中并让 <code>i += 1</code> ，即指针往后移。否则我们就将 <span class="math inline">\(\textit{nums}[j]\)</span> 放入临时数组 <code>tmp</code> 中并让 <code>j += 1</code> 。如果有一个指针已经移到了区间的末尾，那么就把另一个区间里的数按顺序加入 <code>tmp</code> 数组中即可。</p><p>这样能保证我们每次都是让两个区间中较小的数加入临时数组里，那么整个归并过程结束后 <span class="math inline">\([l,r]\)</span> 即为有序的。</p></li></ol><p>如下的动图展示了两个有序数组线性归并的过程：</p><figure><img src="https://assets.leetcode-cn.com/solution-static/912/912_fig4.gif" alt="fig4"><figcaption aria-hidden="true">fig4</figcaption></figure><p>函数递归调用的入口为 <code>mergeSort(nums, 0, nums.length - 1)</code>，递归结束当且仅当 <code>l &gt;= r</code>。</p><h5 id="新知识">新知识</h5><pre class="line-numbers language-none"><code class="language-none">int mid&#x3D;l+((r-l)&gt;&gt;1);&#x2F;* &gt;&gt;二进制运算 &gt;&gt;1 二进制向后移动一位相当于除以2*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="自己的写法">自己的写法</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">>=</span>r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">int</span> mid<span class="token operator">=</span>l<span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>l <span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> l3<span class="token operator">=</span>l<span class="token punctuation">;</span>       <span class="token keyword">int</span> l2<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>       temp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> tempIndex<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;=</span>mid <span class="token operator">&amp;&amp;</span> l2<span class="token operator">&lt;=</span>r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>l2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                temp<span class="token punctuation">[</span>tempIndex<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>l<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>               temp<span class="token punctuation">[</span>tempIndex<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>l2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         temp<span class="token punctuation">[</span>tempIndex<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>l<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>l2<span class="token operator">&lt;=</span>r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            temp<span class="token punctuation">[</span>tempIndex<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>l2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>temp<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             nums<span class="token punctuation">[</span>l3<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="官方写法-1">官方写法</h5><pre class="line-numbers language-Java" data-language="Java"><div class="caption"><span>[sol3-Java]</span></div><code class="language-Java">class Solution &#123;    int[] tmp;    public int[] sortArray(int[] nums) &#123;        tmp &#x3D; new int[nums.length];        mergeSort(nums, 0, nums.length - 1);        return nums;    &#125;    public void mergeSort(int[] nums, int l, int r) &#123;        if (l &gt;&#x3D; r) &#123;            return;        &#125;        int mid &#x3D; (l + r) &gt;&gt; 1;        mergeSort(nums, l, mid);        mergeSort(nums, mid + 1, r);        int i &#x3D; l, j &#x3D; mid + 1;        int cnt &#x3D; 0;        while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r) &#123;            if (nums[i] &lt;&#x3D; nums[j]) &#123;                tmp[cnt++] &#x3D; nums[i++];            &#125; else &#123;                tmp[cnt++] &#x3D; nums[j++];            &#125;        &#125;        while (i &lt;&#x3D; mid) &#123;            tmp[cnt++] &#x3D; nums[i++];        &#125;        while (j &lt;&#x3D; r) &#123;            tmp[cnt++] &#x3D; nums[j++];        &#125;        for (int k &#x3D; 0; k &lt; r - l + 1; ++k) &#123;            nums[k + l] &#x3D; tmp[k];        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<span class="math inline">\(O(n\log n)\)</span>。由于归并排序每次都将当前待排序的序列折半成两个子序列递归调用，然后再合并两个有序的子序列，而每次合并两个有序的子序列需要 <span class="math inline">\(O(n)\)</span> 的时间复杂度，所以我们可以列出归并排序运行时间 <span class="math inline">\(T(n)\)</span> 的递归表达式： <span class="math display">\[T(n)=2T(\frac{n}{2})+O(n)\]</span> ​ 根据主定理我们可以得出归并排序的时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>。</p></li><li><p>空间复杂度：<span class="math inline">\(O(n)\)</span>。我们需要额外 <span class="math inline">\(O(n)\)</span> 空间的 <span class="math inline">\(\textit{tmp}\)</span> 数组，且归并排序递归调用的层数最深为 <span class="math inline">\(\log_2 n\)</span>，所以我们还需要额外的 <span class="math inline">\(O(\log n )\)</span> 的栈空间，所需的空间复杂度即为 <span class="math inline">\(O(n+\log n) = O(n)\)</span>。</p></li></ul><h4 id="方法4冒泡排序">方法4：冒泡排序</h4><p>最简单的排序，不过多解释</p><p>冒泡排序</p><p>​ 从小到大排序</p><p>​ 如果从前往后比较，一次遍历，会让最大的数位于最后一位</p><p>​ 反之，从后往前遍历，会让最小的数位于最前的一位</p><p>因此每遍历一次则减少一个数参与比较</p><h5 id="注意点-1">注意点</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">/*len-i -1  -i是因为遍历一次减少一个数参与比较，-1是为了防止 nums[j+1]溢出*/</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">/*len-i -1  -i是因为遍历一次减少一个数参与比较，-1是为了防止 nums[j+1]溢出*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">/*  这里len 可以优化成len-1 因为n 个数排序只需要遍历n—1次，n-1个数确定，最后一个自然确定*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="完整代码">完整代码</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token class-name">Solution</span> solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ints <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">sortArray</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> ele <span class="token operator">:</span> ints        <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法5插入排序">方法5：插入排序</h4><p>相信大家应该都玩过扑克牌吧，我们平常摸牌时，是不是一边摸牌，一边理牌，摸到新牌时，会将其插到合适的位置。这其实就是我们的插入排序思想。</p><p>直接插入排序：将一个记录插入到已经排好序的有序表中，从而得到一个新的有序表。通俗理解，我们首先将序列分成两个区间，有序区间和无序区间，我们每次在无序区间内取一个值，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间一直有序。下面我们看一下动图吧。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> j<span class="token punctuation">;</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//必须将i的值保存，因为后面的操作中i的值会变化</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//必须使用temp因为后面的操作中i的值会变化</span>                    nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//必须使用j+1，不使用i的原因是因为每个数向后移动一位，使用i可能会导致大家</span>                                          <span class="token comment">//都往一个位置移动</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            j <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//j+1的原因是大家都往后移动了一位，j位比比较值小，所以j+1的位置是空</span>            nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token class-name">Solution</span> solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ints <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">sortArray</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> ele <span class="token operator">:</span> ints        <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="本文非原创很多部分内容转载leetcode"><strong>本文非原创，很多部分内容转载LeetCode</strong></h2>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;排序数组&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sort-an-array/&quot;&gt;912. 排序数组&lt;/a&gt;&lt;/h4&gt;</summary>
    
    
    
    <category term="算法" scheme="https://rds49.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://rds49.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>事务</title>
    <link href="https://rds49.github.io/2021/08/11/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://rds49.github.io/2021/08/11/%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2021-08-11T11:56:05.219Z</published>
    <updated>2021-09-08T02:45:58.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务">事务</h1><h2 id="事务的定义">事务的定义</h2><p>​ 事务是一系列操作的集合，这些操作要么一起做，要么都不做</p><h2 id="事务的性质">事务的性质</h2><h3 id="原子性">1.原子性</h3><p>​ 就是事务的各个操作不可分割</p><h3 id="一致性">2.一致性</h3><p>​ 事务必须使数据库从一个一致性状态变成另一个一致性状态</p><p>​ 这些操作必须一起完成</p><h3 id="隔离性">3.隔离性</h3><p>事务之间互不干扰</p><h3 id="持久性">4.持久性</h3><p>事务对数据库的修改是永久的</p><h2 id="事务的隔离级别">事务的隔离级别</h2><h3 id="脏读读未提交">1.脏读（读未提交）</h3><p>​ 事务A读到事务B未提交的数据，这样A读取的数据就是错误的</p><h3 id="不可重复读提交读">2.不可重复读（提交读）</h3><p>​ 同一个事务两次同样的操作读取的数据不一致</p><p>​ 事务A执行select操作，事务B update数据，事务A二次select这样两次select获取的数据不一致</p><h3 id="幻读">3.幻读</h3><p>​ update的操作不会造成影响，但是insert的会造成影响，与级别2相同</p><h3 id="序列化读">4.序列化读</h3><p>​ 这也就是最高级别，保证事务之间不会有任何踩踏，每个事务都可以认为只有它自己在操作数据库。</p><h2 id="事务的调度">事务的调度</h2><h3 id="串行">串行</h3><p>​ 相当于单线程，大家一个一个来</p><h3 id="并行">并行</h3><p>​ 相当于多线程，可以多个一起来</p><h2 id="并发控制">并发控制</h2><p>如果事务不加控制就并发执行，会发生以下错误</p><h3 id="丢失更新">1.丢失更新</h3><p>两个事务A和B读入同一数据并修改，B的提交结果破坏了A的提交结果</p><p>例：购买飞机票</p><h3 id="不可重复读">2.不可重复读</h3><p>这里的不可重复读与隔离级别的有点区别,这里的不可重复读包括增，删，改3种情况</p><p>隔离级别的不可重复读只包阔改</p><h3 id="读脏数据">3.读''脏''数据</h3><p>​</p><h2 id="封锁">封锁</h2><h3 id="基本的封锁类型">基本的封锁类型</h3><h4 id="共享锁读锁">共享锁（读锁）</h4><p>​ 事务T对象A加上共享锁，则T只能读不能写，其他事务只能对A再加共享锁，不能加排他锁</p><h4 id="排他锁写锁">排他锁（写锁）</h4><p>​ 事务T对对象A加上排他锁，则只允许事务T可以对A进行读取和修改，其他对象不可以对A加任何的锁，直到事务T释放A</p><h3 id="死锁与或活锁">死锁与或活锁</h3><p>事务使用封锁机制后，会产生活锁和死锁问题。</p><h4 id="活锁">1.活锁</h4><p>​ 如果事务T,封锁了数据R,事务T2又请求封锁R,于是T2等待。T也请求封锁R,当T,释放了R上的封锁之后系统先批准了T3的请求，于是T2继续等待。然后T:又请求封锁R,当T3释放了R上的封锁之后系统又先批准了T-的请求，…,T2有可能永远在等待。 这种在多个事务请求对同一个数据封锁时，使某一事务总是处于等待的状况称为活锁。 ​ 避免活锁的方法可以采用先来先服务的策略、时间片等算法</p><h4 id="死锁">2.死锁</h4><p>​ 如果事务T封锁了数据R,T2封锁了数据R2,然后T又请求封锁R2,因T2已封锁了R2,于是T,等待T2释放R2上的锁。接着T2又申请封锁R1,因T,已封锁了R1,T2也只能等待T释放R上的锁。这样就出现了T,在等待T2,T2又在等待T,的局面，T,和T2两个事务永远不会结束，形成死锁。 ​ 死锁的问题在操作系统和一般并行处理中已做了深入研究，目前在数据库中解决死锁问题主要有两种方法：一种方法是采取一定措施来预防死锁的发生；另一种方法是允许发生死锁，采取一定手段定期诊断系统中有无死锁，若有则解除之。</p><h4 id="预防死锁">预防死锁</h4><p>​ 1.一次封锁法</p><p>​ 2.顺序封锁法</p><p><strong>一次封锁法</strong>：一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。如果事务T,将数据对象R1和R2一次加锁，T就可以执行下去，而T等待。T,执行完后释放R1,R2上的锁，T2继续执行。这样就不会发生死锁。</p><p>一次封锁法虽然可以有效地防止死锁的发生，但也存在问题。第一，一次就将以后要用到的全部数据加锁，势必扩大了封锁的范围，从而降低了系统的并发度；第二，数据库中的数据是不断变化的，原来不要求封锁的数据在执行过程中可能会变成封锁对象，所以很难事先精确地确定每个事务所要封锁的数据对象，为此只能扩大封锁范围，将事务在执行过程中可能要封锁的数据对象全部加锁，这就进一步降低了并发度。 <strong>顺序封锁法</strong>：顺序封锁法是预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。例如，在B树结构的索引中，可规定封锁的顺序必须是从根结点开始，然后是下一级的子女结点，逐级封锁。</p><p>顺序封锁法可以有效地防止死锁，但也同样存在问题。第一，数据库系统封锁的数据对象极多，并且随数据的插入、删除等操作而不断地变化，要维护这样的资源的封锁顺序非常困难，成本很高；第二，事务的封锁请求可以随着事务的执行而动态地决定，很难事先确定每一个事务要封锁哪些对象，因此也就很难按规定的顺序去施加封锁。 可见，在操作系统中广为采用的预防死锁的策略并不很适合数据库的特点，因此DBMS在解决死锁的问题上普遍采用的是诊断并解除死锁的方法。</p><p><strong>预防死锁的方法处理对象多，成本高，实际过程中更多采用诊断并解除死死锁的方法</strong></p><h4 id="死锁的诊断与解除">死锁的诊断与解除</h4><p>​ 1.超时法</p><p>​ 2.等待图法</p><p>​ 数据库系统中诊断死锁的方法与操作系统类似，一般使用超时法或事务等待图法。 ​ 1)超时法。如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。超时法实现简单，但其不足也很明显。一是有可能误判死锁，事务因为其他原因使等待时间超过时限，系统会误认为发生了死锁；二是时限若设置得太长，死锁发生后不能及时发现。 ​ 2)等待图法。等待图法是一个有向图G=(T,U).T为结点的集合，每个结点表示正运行的事务；U为边的集合，每条边表示事务等待的情况。若T,等待T2,则T,T2之间划一条有向边，从T指向T2。事务等待图动态地反映了所有事务的等待情况。并发控制子系统周期性地(比如每隔1min)检测事务等待图，如果发现图中存在回路，则表示系统中出现了死锁。 ​ DBMS的并发控制子系统一旦检测到系统中存在死锁，就要设法解除。通常采用的方法是选择一个<strong>处理死锁代价最小的事务，将其撤消</strong>，释放此事务持有的所有的锁，使其他事务得以继续运行下去。当然，对撤消的事务所执行的数据修改操作必须加以恢复。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;事务&quot;&gt;事务&lt;/h1&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://rds49.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="https://rds49.github.io/tags/SQL/"/>
    
    <category term="数据库" scheme="https://rds49.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="事务" scheme="https://rds49.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>刷题</title>
    <link href="https://rds49.github.io/2021/08/09/LeetCode/"/>
    <id>https://rds49.github.io/2021/08/09/LeetCode/</id>
    <published>2021-08-09T11:48:09.186Z</published>
    <updated>2021-09-06T04:12:56.545Z</updated>
    
    <content type="html"><![CDATA[<h3 id="两数之和">两数之和</h3><p>0722</p><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h4 id="思路一利用hashmap值对应数组下标">思路一：利用HashMap&lt;值，对应数组下标&gt;</h4><p>先查再存，避免自己查到自己</p><pre class="line-numbers language-none"><code class="language-none">boolean is&#x3D;map.containsKey(target-numbers[i]);                        if(is)&#123;                            b&#x3D;i;                            a&#x3D;map.get(target-numbers[i]);                        break;                  &#125;                   map.put(numbers[i],i);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完整代码：</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int[] twoSum(int[] numbers, int target) &#123;             Map&lt;Integer,Integer&gt; map&#x3D;new HashMap&lt;&gt;();             int a&#x3D;0;             int b&#x3D;0;             for(int i&#x3D;0;i&lt;numbers.length;i++)&#123;                   boolean is&#x3D;map.containsKey(target-numbers[i]);                        if(is)&#123;                            b&#x3D;i;                            a&#x3D;map.get(target-numbers[i]);                        break;                  &#125;                   map.put(numbers[i],i);                            &#125;             int result[]&#x3D;new int[2];             result[0]&#x3D;a+1;             result[1]&#x3D;b+1;&#x2F;&#x2F;升序的特点，所以b&gt;a;因为b还没有存进去，a已经存入             return result;                 &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="思路二双指针">思路二：双指针</h4><p>​ 双指针，利用升序的特点，两个指针位于头尾，&gt;target right--,&lt;target left ++</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int[] twoSum(int[] numbers, int target) &#123;            int left &#x3D;0;            int right &#x3D;numbers.length-1;            while(left&lt;right)&#123;                               if(numbers[left]+numbers[right]&#x3D;&#x3D;target)&#123;                      int result[]&#x3D;new int[2];                         result[0]&#x3D;left+1;                         result[1]&#x3D;right+1;                   return result;               &#125;               if(numbers[left]+numbers[right]&gt;target)&#123;                    right--;               &#125;               if(numbers[left]+numbers[right]&lt;target)&#123;                  left++;               &#125;            &#125;           return null;    &#125;            &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="思路3二分查找苯办法">思路3：二分查找，苯办法</h4><p>在数组中找到两个数，使得它们的和等于目标值，可以首先固定第一个数，然后寻找第二个数，第二个数等于目标值减去第一个数的差。利用数组的有序性质，可以通过二分查找的方法寻找第二个数。为了避免重复寻找，在寻找第二个数时，只在第一个数的右侧寻找。</p><p>（官方解法，转载）</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int[] twoSum(int[] numbers, int target) &#123;        for (int i &#x3D; 0; i &lt; numbers.length; ++i) &#123;            int low &#x3D; i + 1, high &#x3D; numbers.length - 1;            while (low &lt;&#x3D; high) &#123;                int mid &#x3D; (high - low) &#x2F; 2 + low;                if (numbers[mid] &#x3D;&#x3D; target - numbers[i]) &#123;                    return new int[]&#123;i + 1, mid + 1&#125;;                &#125; else if (numbers[mid] &gt; target - numbers[i]) &#123;                    high &#x3D; mid - 1;                &#125; else &#123;                    low &#x3D; mid + 1;                &#125;            &#125;        &#125;        return new int[]&#123;-1, -1&#125;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="两数相加">两数相加</h3><p>0723</p><p><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>因为是逆序的链表，单纯的指针进位，</p><p>但是最后一位进位容易忽略（因为我们的常用循环条件是节点非空，但是最后两个节点之和大于10应该再进一位）</p><p>所以循环结束应该再执行一次</p><p>自己的写法</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val &#x3D; val; &#125; *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125; * &#125; *&#x2F;class Solution &#123;    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;                  ListNode result&#x3D;new ListNode(-1);                    ListNode currentNode&#x3D;new ListNode();                  int next&#x3D;0;                              while( l1!&#x3D;null || l2 !&#x3D;null)&#123;                      int j;                      if(l1&#x3D;&#x3D;null )&#123;                          j&#x3D;l2.val;                           l2&#x3D;l2.next;                      &#125;else if (l2&#x3D;&#x3D;null)&#123;                          j&#x3D;l1.val;                           l1&#x3D;l1.next;                      &#125;else&#123;                          j&#x3D;l2.val+l1.val;                           l1&#x3D;l1.next;                           l2&#x3D;l2.next;                      &#125;                                          int current&#x3D;(j+next)%10;                     next&#x3D;(j+next)&#x2F;10;                   if(result.val&#x3D;&#x3D;-1)&#123;                           result.val&#x3D;current;                                         currentNode&#x3D;result;                    &#125;else&#123;                          ListNode newNode&#x3D;new ListNode(current);                          currentNode.next&#x3D;newNode;                          currentNode&#x3D;currentNode.next;                    &#125;                        &#125;                  if(next!&#x3D;0)&#123;                       ListNode newNode&#x3D;new ListNode(next);                          currentNode.next&#x3D;newNode;                          currentNode&#x3D;currentNode.next;                  &#125;                  return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>官方题解</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;        ListNode head &#x3D; null, tail &#x3D; null;        int carry &#x3D; 0;        while (l1 !&#x3D; null || l2 !&#x3D; null) &#123;            int n1 &#x3D; l1 !&#x3D; null ? l1.val : 0;            int n2 &#x3D; l2 !&#x3D; null ? l2.val : 0;            int sum &#x3D; n1 + n2 + carry;            if (head &#x3D;&#x3D; null) &#123;                head &#x3D; tail &#x3D; new ListNode(sum % 10);            &#125; else &#123;                tail.next &#x3D; new ListNode(sum % 10);                tail &#x3D; tail.next;            &#125;            carry &#x3D; sum &#x2F; 10;            if (l1 !&#x3D; null) &#123;                l1 &#x3D; l1.next;            &#125;            if (l2 !&#x3D; null) &#123;                l2 &#x3D; l2.next;            &#125;        &#125;        if (carry &gt; 0) &#123;            tail.next &#x3D; new ListNode(carry);        &#125;        return head;    &#125;&#125;作者：LeetCode-Solution链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;add-two-numbers&#x2F;solution&#x2F;liang-shu-xiang-jia-by-leetcode-solution&#x2F;来源：力扣（LeetCode）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="寻找两个正序数组的中位数"><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></h3><p>0724</p><h4 id="思路1双指针">思路1：双指针</h4><p>合并两个数组找中位数，或者不合并数组，找到中间的俩个数或一个数即可</p><p>然而此方法并不是最优</p><p>​ 前者的时间复杂度是 O(m+n)，空间复杂度是 O(m+n)。优化后虽然可以将空间复杂度降到 O(1)，但是时间复杂度仍是 O(m+n)。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;                    if(nums1.length&#x3D;&#x3D;0 &amp;&amp;nums2.length !&#x3D;0)&#123;            if(nums2.length%2&#x3D;&#x3D;0)&#123;                    return (nums2[nums2.length&#x2F;2]+nums2[nums2.length&#x2F;2-1])*1.0&#x2F;2;            &#125;else&#123;                return nums2[nums2.length&#x2F;2];            &#125;        &#125;        if(nums2.length&#x3D;&#x3D;0 &amp;&amp; nums1.length !&#x3D;0)&#123;            if(nums1.length%2&#x3D;&#x3D;0)&#123;                    return (nums1[nums1.length&#x2F;2]+nums1[nums1.length&#x2F;2-1])*1.0&#x2F;2;            &#125;else&#123;                return nums1[nums1.length&#x2F;2];            &#125;        &#125;        if(nums2.length&#x3D;&#x3D;0 &amp;&amp; nums1.length &#x3D;&#x3D;0)&#123;                    return -99999;        &#125;            int all[]&#x3D;new int[nums1.length+nums2.length];            int left1&#x3D;0;            int left2&#x3D;0;            int count&#x3D;0;        while(count&lt;all.length)&#123;            if(left1&gt;&#x3D;nums1.length)&#123;                    all[count]&#x3D;nums2[left2];                    left2++;            &#125;else             if(left2&gt;&#x3D;nums2.length)&#123;                    all[count]&#x3D;nums1[left1];                    left1++;            &#125; else            if(nums1[left1]&lt;nums2[left2])&#123;                    all[count]&#x3D;nums1[left1];                    left1++;                           &#125;            else            if(nums1[left1]&gt;&#x3D;nums2[left2])&#123;                all[count]&#x3D;nums2[left2];                    left2++;                                &#125;                count++;            &#125;            if(all.length%2&#x3D;&#x3D;0)&#123;                            return (all[all.length&#x2F;2]+all[all.length&#x2F;2-1])*1.0&#x2F;2;                    &#125;                        return all[all.length&#x2F;2];                                      &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="思路2二分查找">思路2：二分查找</h4><h3 id="最长回文子串"><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></h3><p>0726</p><h4 id="暴力破解">1：暴力破解</h4><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public boolean is(String s,int left ,int right)&#123;                   while(s.charAt(left)&#x3D;&#x3D;s.charAt(right))&#123;              left++;              right--;              if(left&gt;&#x3D;right)&#123;                   return true;              &#125;          &#125;          return false;    &#125;    public String longestPalindrome(String s) &#123;        String max&#x3D;String.valueOf(s.charAt(0));          for(int i&#x3D;0;i&lt;s.length()-1;i++)&#123;             int left&#x3D;i;             int right&#x3D;s.length()-1;              boolean isH&#x3D; is(s,left,right);              while(right &gt;left &amp;!isH)&#123;                    right--;                   isH&#x3D; is(s,left,right);                &#125;              if(isH)&#123;            String temp&#x3D;s.substring(left,right+1);            if(temp.length()&gt;max.length())&#123;                   max&#x3D;temp;            &#125;            &#125;          &#125;          return max;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="动态规划">2：动态规划</h4><h4 id="中心扩散">3：中心扩散</h4><h4 id="manacher-算法">4：Manacher 算法</h4><h3 id="正则表达式匹配"><a href="https://leetcode-cn.com/problems/regular-expression-matching/">正则表达式匹配</a></h3><p>0727</p><h4 id="动态规划-1">1：动态规划</h4><p>详情看官方解释吧</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public boolean isMatch(String s, String p) &#123;               String s1&#x3D;&quot; &quot;+s;               String p1&#x3D;&quot; &quot;+p;               int dp[][]&#x3D;new int[s.length()+1][p.length()+1];               for(int i&#x3D;0;i&lt;dp.length;i++)&#123;                  dp[i][0]&#x3D;0;               &#125;               dp[0][0]&#x3D;1;               for(int j&#x3D;1;j&lt;dp[0].length;j++)&#123;                  dp[0][j]&#x3D;0;               &#125;                for(int j&#x3D;0;j&lt;dp[0].length;j++)&#123;                  if(p1.charAt(j)&#x3D;&#x3D;&#39;*&#39;)&#123;                    dp[0][j]&#x3D;dp[0][j-2];                  &#125;                &#125;               for(int i&#x3D;1;i&lt;s1.length();i++)&#123;                   for(int j&#x3D;1;j&lt;p1.length();j++)&#123;                       if(p1.charAt(j)&#x3D;&#x3D;&#39;*&#39;)&#123;                          if(dp[i][j-2]&#x3D;&#x3D;0)&#123;                              if(s1.charAt(i)&#x3D;&#x3D;p1.charAt(j-1) ||p1.charAt(j-1)&#x3D;&#x3D;&#39;.&#39;)&#123;                               dp[i][j]&#x3D;dp[i-1][j];                           &#125;                            &#125;else&#123;                                dp[i][j]&#x3D;1;                           &#125;                       &#125;else if(p1.charAt(j)&#x3D;&#x3D;&#39;.&#39;)&#123;                                 dp[i][j]&#x3D;dp[i-1][j-1];                       &#125;else if(p1.charAt(j)&#x3D;&#x3D;s1.charAt(i)) &#123;                                     dp[i][j]&#x3D;dp[i-1][j-1];                       &#125;else&#123;                               dp[i][j]&#x3D;0;                       &#125;                   &#125;               &#125;               if(dp[s.length()][p.length()]&#x3D;&#x3D;1)&#123;                         return true;               &#125;               return false;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="z-字形变换"><a href="https://leetcode-cn.com/problems/zigzag-conversion/">Z 字形变换</a></h3><h4 id="按行排序">1：按行排序</h4><p><strong>思路</strong></p><p>通过从左向右迭代字符串，我们可以轻松地确定字符位于 Z 字形图案中的哪一行。</p><p><strong>算法</strong></p><p>我们可以使用 Math.min(numRows, s.length() 个列表来表示 Z 字形图案中的非空行。</p><p>从左到右迭代 ss，将每个字符添加到合适的行。可以使用当前行和当前方向这两个变量对合适的行进行跟踪。</p><p>只有当我们向上移动到最上面的行或向下移动到最下面的行时，当前方向才会发生改变。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public String convert(String s, int numRows) &#123;        if (numRows &#x3D;&#x3D; 1) return s;        List&lt;StringBuilder&gt; rows &#x3D; new ArrayList&lt;&gt;();        for (int i &#x3D; 0; i &lt; Math.min(numRows, s.length()); i++)            rows.add(new StringBuilder());        int curRow &#x3D; 0;        boolean goingDown &#x3D; false;        for (char c : s.toCharArray()) &#123;            rows.get(curRow).append(c);            if (curRow &#x3D;&#x3D; 0 || curRow &#x3D;&#x3D; numRows - 1) goingDown &#x3D; !goingDown;            curRow +&#x3D; goingDown ? 1 : -1;        &#125;        StringBuilder ret &#x3D; new StringBuilder();        for (StringBuilder row : rows) ret.append(row);        return ret.toString();    &#125;&#125;作者：LeetCode链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion&#x2F;solution&#x2F;z-zi-xing-bian-huan-by-leetcode&#x2F;来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="按行访问">2：按行访问</h4><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public String convert(String s, int numRows) &#123;        if(numRows&#x3D;&#x3D;1)&#123;              return s;        &#125;      StringBuilder stringBuilder &#x3D; new StringBuilder();              for (int i &#x3D; 1; i &lt;&#x3D; numRows; i++) &#123;            if (i &#x3D;&#x3D; 1 || i &#x3D;&#x3D; numRows) &#123;                int index &#x3D; i - 1;                while (index &lt; s.length()) &#123;                    stringBuilder.append(s.charAt(index));                    index &#x3D; index + 2 * numRows - 2;                &#125;            &#125; else &#123;                int index &#x3D; i - 1;                int jy &#x3D; 0;                while (index &lt; s.length()) &#123;                    stringBuilder.append(s.charAt(index));                    if (jy &#x3D;&#x3D; 0) &#123;                        index &#x3D; index + 2 * numRows - 2 * i;                        jy &#x3D; 1;                    &#125; else &#123;                        index &#x3D; index + 2 * (i - 1);                                 jy &#x3D; 0;                    &#125;                &#125;            &#125;        &#125;        String s1 &#x3D; stringBuilder.toString();        return s1;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="盛最多水的容器"><a href="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器</a></h2><p>给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器。</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg"></p><p>初次解题思路</p><p>双指针：</p><p>初始状态：左指针0 右指针 length-1</p><p>如果左指针对应的高小，那么左指针向右移动，直到找到比左指针高的垂直线，停止。（只有比它高的垂直线才有可能提高容积，毕竟底变短了，那么高必须增大）</p><p>右指针同理</p><p>例子： 2,3,10,5,7,8,9</p><p>初始left=0,right=6 ，2&lt;9应该是left移动，这里假设是right移动，那么right会直接找到10，right=2</p><p>那么最大的结过就是 left=1,right=6,h=3 容积=15</p><p>这样一来就会直接忽略7，8</p><p>你会发现假设选取10， 8这两个垂直线计算 容积为 3*8=24</p><p>因此必须是谁小谁移动</p><p>初次写法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> height<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>r <span class="token operator">></span> l<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">minNum</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> area <span class="token operator">=</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">*</span> height<span class="token punctuation">[</span>h<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>area <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                max <span class="token operator">=</span> area<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rl <span class="token operator">=</span> <span class="token function">getLandR</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> height<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>                r <span class="token operator">=</span> rl<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                l <span class="token operator">=</span> rl<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getLandR</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> r <span class="token operator">==</span> i <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>r <span class="token operator">></span> l<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">>=</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    l<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>r <span class="token operator">></span> l<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">>=</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    r<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>l<span class="token punctuation">,</span> r<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> height<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">?</span> j <span class="token operator">:</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token class-name">Solution</span> solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>solution<span class="token punctuation">.</span><span class="token function">maxArea</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的处理可以完善</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token keyword">while</span> <span class="token punctuation">(</span>r <span class="token operator">></span> l<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">minNum</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> area <span class="token operator">=</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">*</span> height<span class="token punctuation">[</span>h<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//这行的计算会在同一个点计算两边，</span><span class="token comment">//因为第一次计算是计算面积，但r，l不会改变，只有当第二次计算时判断area > max（此时为相等）为false才会执行r,l的移动代码</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>area <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                max <span class="token operator">=</span> area<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rl <span class="token operator">=</span> <span class="token function">getLandR</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> height<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>                r <span class="token operator">=</span> rl<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                l <span class="token operator">=</span> rl<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化后</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>r<span class="token operator">></span>l<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token keyword">int</span> h<span class="token operator">=</span> <span class="token function">minNum</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>r<span class="token punctuation">,</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">int</span> area<span class="token operator">=</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">*</span>height<span class="token punctuation">[</span>h<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>area<span class="token operator">></span>max<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>              max<span class="token operator">=</span>area<span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">&lt;</span>height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>              <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rl <span class="token operator">=</span> <span class="token function">getLandR</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> height<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>              r <span class="token operator">=</span> rl<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>              l <span class="token operator">=</span> rl<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>              <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rl <span class="token operator">=</span> <span class="token function">getLandR</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> height<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>              r <span class="token operator">=</span> rl<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>              l <span class="token operator">=</span> rl<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过不知道为什么，优化后，leetcode给出的运行时间变长了，占用内存变小了</p><h2 id="电话号码的字母组合"><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合</a></h2><p>自己的写法</p><p>单纯的循环遍历</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">letterCombinations</span><span class="token punctuation">(</span><span class="token class-name">String</span> digits<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> index<span class="token operator">=</span><span class="token number">97</span><span class="token punctuation">;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">></span></span> map<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">9</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span> <span class="token number">7</span> <span class="token operator">||</span> i<span class="token operator">==</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                k<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>k<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                a<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span>index<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;</span>digits<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">Integer</span> q<span class="token operator">=</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>digits<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> w<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> s<span class="token operator">=</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>w<span class="token operator">&lt;</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token operator">+</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                      w<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                w<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>w<span class="token operator">&lt;</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    w<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回溯法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">letterCombinations</span><span class="token punctuation">(</span><span class="token class-name">String</span> digits<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> combinations <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>digits<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> combinations<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> phoneMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>            <span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">"def"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">"ghi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">"jkl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'6'</span><span class="token punctuation">,</span> <span class="token string">"mno"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'7'</span><span class="token punctuation">,</span> <span class="token string">"pqrs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'8'</span><span class="token punctuation">,</span> <span class="token string">"tuv"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'9'</span><span class="token punctuation">,</span> <span class="token string">"wxyz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token function">backtrack</span><span class="token punctuation">(</span>combinations<span class="token punctuation">,</span> phoneMap<span class="token punctuation">,</span> digits<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> combinations<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> combinations<span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> phoneMap<span class="token punctuation">,</span> <span class="token class-name">String</span> digits<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">StringBuffer</span> combination<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> digits<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            combinations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>combination<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">char</span> digit <span class="token operator">=</span> digits<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> letters <span class="token operator">=</span> phoneMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>digit<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> lettersCount <span class="token operator">=</span> letters<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lettersCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                combination<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>letters<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">backtrack</span><span class="token punctuation">(</span>combinations<span class="token punctuation">,</span> phoneMap<span class="token punctuation">,</span> digits<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> combination<span class="token punctuation">)</span><span class="token punctuation">;</span>                combination<span class="token punctuation">.</span><span class="token function">deleteCharAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除链表的倒数第-n-个结点"><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a></h2><h3 id="先后指针">先后指针</h3><h4 id="我的写法">我的写法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">ListNode</span> node<span class="token operator">=</span>head<span class="token punctuation">;</span>    <span class="token class-name">ListNode</span> node1<span class="token operator">=</span>head<span class="token punctuation">;</span>    <span class="token keyword">int</span> n1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">ListNode</span> node2<span class="token operator">=</span> head<span class="token punctuation">;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>node2<span class="token punctuation">.</span>next<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           node2<span class="token operator">=</span>node2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>           n2<span class="token operator">++</span><span class="token punctuation">;</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>n2<span class="token operator">-</span>n1<span class="token operator">></span>n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>              n1<span class="token operator">++</span><span class="token punctuation">;</span>              node1<span class="token operator">=</span>node1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>n1<span class="token operator">==</span>n2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>n2<span class="token operator">-</span>n1<span class="token operator">&lt;</span>n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           <span class="token keyword">return</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>           node1<span class="token punctuation">.</span>next<span class="token operator">=</span>node1<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>           <span class="token keyword">return</span> node<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">if(n1&#x3D;&#x3D;n2)&#123;          return null;     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>相等是为了解决[2] ,1这种情况，这种两着都没有移动</p><pre class="line-numbers language-none"><code class="language-none">if(n2-n1&lt;n)&#123;           return node.next;      &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个判断条件是为了解决链表长度与n相等的情况，[1,2,3,4] ,4 因为我们是通过前后指针相差n+1来获取删除节点前面一个节点来进行操作的</p><p>当链表长度与n相等时就无法使得前后指针相差n+ 1 而这种情况刚好删除第一个节点，因此特殊处理</p><p>仔细发现前面一种情况包含在这种情况下，索引相等的那个情况的代码其实可以删除</p><h4 id="官方解法设置了一个前置虚拟节点">官方解法，设置了一个前置虚拟节点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ListNode</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> first <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> second <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            first <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            first <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            second <span class="token operator">=</span> second<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        second<span class="token punctuation">.</span>next <span class="token operator">=</span> second<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> ans <span class="token operator">=</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="栈">栈</h3><p>因为是反向删除节点，刚好对应栈先进后出的性质，</p><p>先遍历一次将所有节点放入栈中，再出栈，第n个出栈的数就是要删除的节点，当然删除倒数第n个节点要获取第n-1个节点，因此出栈获取的是n+1和n-1这两个节点，将两个节点一连即可</p><h2 id="无重复字符的最长子串"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><p>滑动窗口，说白了就是双指针</p><h3 id="自己的写法">自己的写法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> hm<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">int</span> l<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">int</span> r<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">int</span> max<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">while</span><span class="token punctuation">(</span>r<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">boolean</span> is<span class="token operator">=</span>hm<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> k<span class="token operator">=</span>r<span class="token operator">-</span>l<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">></span>max<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                       max<span class="token operator">=</span>k<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                  <span class="token keyword">int</span> end<span class="token operator">=</span>hm<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>l<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>end<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                      hm<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      l<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                           <span class="token punctuation">&#125;</span>            hm<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>            r<span class="token operator">++</span><span class="token punctuation">;</span>             <span class="token punctuation">&#125;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token operator">></span>max<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> r<span class="token operator">-</span>l<span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>              <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="官方的写法1">官方的写法1</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                left <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            max <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span>i<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>精妙的解法，通过数组中的值存储字母出现的位置，二次出现就比较（左指针）与（上传出现的值+1）谁大，谁大，左指针就是谁</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 记录字符上一次出现的位置</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> last <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">128</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            last<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 窗口开始位置</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            start <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> last<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res   <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> i <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            last<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="有效的括号"><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h2><p>代码鬼才</p><p>直接将"（）"替换成 ""</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*@别人的代码，我提交了一遍执行用时：53 ms, 在所有 Java 提交中击败了5.48%的用户内存消耗：40.1 MB, 在所有 Java 提交中击败了5.02%的用户2020年8月14日 6:49*/</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"()"</span><span class="token punctuation">)</span><span class="token operator">||</span>s<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"[]"</span><span class="token punctuation">)</span><span class="token operator">||</span>s<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"()"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                s<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"()"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                s<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"[]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                s<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"[]"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>栈</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Character</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'&#125;'</span><span class="token punctuation">,</span> <span class="token string">'&#123;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">']'</span><span class="token punctuation">,</span> <span class="token string">'['</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="填充每个节点的下一个右侧节点指针"><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h2><h3 id="层次遍历">层次遍历</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 初始化队列同时将第一层节点加入队列中，即根节点</span>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">></span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 外层的 while 循环迭代的是层数</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 记录当前队列大小</span>            <span class="token keyword">int</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 遍历这一层的所有节点</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token comment">// 从队首取出元素</span>                <span class="token class-name">Node</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 连接</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    node<span class="token punctuation">.</span>next <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                                <span class="token comment">// 拓展下一层节点</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 返回根节点</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="利用已建立的next指针">利用已建立的next指针</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>               root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>next<span class="token operator">=</span>root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>               <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>next<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>               root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>next<span class="token operator">=</span>root<span class="token punctuation">.</span>next<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                       <span class="token punctuation">&#125;</span>        <span class="token function">connect</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">connect</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>     <span class="token keyword">return</span> root<span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="合并二叉树"><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h2><p>递归解法 为节约空间可以在已给出的树中存值 ### 我的解法 <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val = val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val = val; *         this.left = left; *         this.right = right; *     &#125; * &#125; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root1<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> root2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>root1<span class="token operator">==</span><span class="token keyword">null</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> root2<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>root2<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> root1<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>           <span class="token function">cunc</span><span class="token punctuation">(</span>root1<span class="token punctuation">,</span>root2<span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> root1<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cunc</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node1<span class="token punctuation">,</span><span class="token class-name">TreeNode</span> node2<span class="token punctuation">,</span><span class="token class-name">TreeNode</span> nodeF<span class="token punctuation">,</span><span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>node1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node2 <span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                 <span class="token keyword">return</span> <span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>node1 <span class="token operator">==</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node2 <span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        node1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>node2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                 nodeF<span class="token punctuation">.</span>left<span class="token operator">=</span>node1<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                nodeF<span class="token punctuation">.</span>right<span class="token operator">=</span>node1<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">cunc</span><span class="token punctuation">(</span>node1<span class="token punctuation">.</span>left<span class="token punctuation">,</span>node2<span class="token punctuation">.</span>left<span class="token punctuation">,</span>node1<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">cunc</span><span class="token punctuation">(</span>node1<span class="token punctuation">.</span>right<span class="token punctuation">,</span>node2<span class="token punctuation">.</span>right<span class="token punctuation">,</span>node1<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span><span class="token keyword">else</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>node1 <span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node2 <span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>              node1<span class="token punctuation">.</span>val<span class="token operator">=</span>node1<span class="token punctuation">.</span>val<span class="token operator">+</span>node2<span class="token punctuation">.</span>val<span class="token punctuation">;</span>               <span class="token function">cunc</span><span class="token punctuation">(</span>node1<span class="token punctuation">.</span>left<span class="token punctuation">,</span>node2<span class="token punctuation">.</span>left<span class="token punctuation">,</span>node1<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token function">cunc</span><span class="token punctuation">(</span>node1<span class="token punctuation">.</span>right<span class="token punctuation">,</span>node2<span class="token punctuation">.</span>right<span class="token punctuation">,</span>node1<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> ### 评论中不错的解法 <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">mergeTrees_1</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> t1<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> t2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> t2<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> t1<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 先合并根节点</span>        t1<span class="token punctuation">.</span>val <span class="token operator">+=</span> t2<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token comment">// 再递归合并左右子树</span>        t1<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> t1<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 不修改原二叉树的解法     */</span>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> t1<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> t2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> t2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 先合并根节点</span>        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token punctuation">(</span>t1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> t1<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>t2 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> t2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 再递归合并左右子树</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>t1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> t1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> t2 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> t2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>t1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> t1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> t2 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> t2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> 该解法中与我的算法思想一致 但有一个最精华的点，即空节点如何和父亲节点连接的问题 <pre class="line-numbers language-java" data-language="java"><code class="language-java">root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>t1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> t1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> t2 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> t2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>t1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> t1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> t2 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> t2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre> 利用返回值的方法将子代的值传递给父代，该是想有点像react中的props ### 官方的解法 <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> t1<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> t2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> t2<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> t1<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">TreeNode</span> merged <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>val <span class="token operator">+</span> t2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        merged<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        merged<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> merged<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> 这里的写法更为优秀，代码量少。</p><h2 id="岛屿的最大面积"><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></h2><h3 id="深度优先算法">深度优先算法</h3><h4 id="自己的写法-1">自己的写法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxAreaOfIsland</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> max<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>              <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                                    <span class="token keyword">int</span> a<span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                max<span class="token operator">=</span> a<span class="token operator">></span>max <span class="token operator">?</span> a<span class="token operator">:</span>max<span class="token punctuation">;</span>              <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span><span class="token keyword">int</span> sl<span class="token punctuation">,</span><span class="token keyword">int</span> sc <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> sl<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">||</span> sl <span class="token operator">>=</span>grid<span class="token punctuation">.</span>length <span class="token operator">||</span>sc <span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span>sc <span class="token operator">>=</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">||</span> grid<span class="token punctuation">[</span>sl<span class="token punctuation">]</span><span class="token punctuation">[</span>sc<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">2</span> <span class="token operator">||</span>grid<span class="token punctuation">[</span>sl<span class="token punctuation">]</span><span class="token punctuation">[</span>sc<span class="token punctuation">]</span> <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                                   grid<span class="token punctuation">[</span>sl<span class="token punctuation">]</span><span class="token punctuation">[</span>sc<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>                                        <span class="token keyword">int</span> a1<span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>sl<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> sc<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token keyword">int</span> a2<span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>sl<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> sc<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token keyword">int</span> a3<span class="token operator">=</span><span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>sl<span class="token punctuation">,</span> sc<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token keyword">int</span> a4<span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>sl<span class="token punctuation">,</span> sc<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>a1<span class="token operator">+</span>a2<span class="token operator">+</span>a3<span class="token operator">+</span>a4<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="官方的写法">官方的写法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxAreaOfIsland</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">!=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                ans <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span> cur_i<span class="token punctuation">,</span> <span class="token keyword">int</span> cur_j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur_i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> cur_j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> cur_i <span class="token operator">==</span> grid<span class="token punctuation">.</span>length <span class="token operator">||</span> cur_j <span class="token operator">==</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">||</span> grid<span class="token punctuation">[</span>cur_i<span class="token punctuation">]</span><span class="token punctuation">[</span>cur_j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        grid<span class="token punctuation">[</span>cur_i<span class="token punctuation">]</span><span class="token punctuation">[</span>cur_j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> di <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">!=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> next_i <span class="token operator">=</span> cur_i <span class="token operator">+</span> di<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> next_j <span class="token operator">=</span> cur_j <span class="token operator">+</span> dj<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>            ans <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> next_i<span class="token punctuation">,</span> next_j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="评论区写法">评论区写法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxAreaOfIsland</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    max <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span>max <span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> grid<span class="token punctuation">.</span>length <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">>=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">||</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        count <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        count <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        count <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        count <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="广度优先算法">广度优先算法</h3><p>就是利用队列</p><p>利用队列先进后出的特点</p><h2 id="组合"><a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></h2><h3 id="回溯法">回溯法</h3><p>递归实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> temp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">combine</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token function">c</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>k<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                              <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>n<span class="token operator">-</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                          <span class="token keyword">return</span> <span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                              res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                     temp<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">c</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>k<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            temp<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">c</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>k<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="合并两个有序链表"><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><p>0905 简单题，无非是数组的合并变成了链表的合并</p><h3 id="自己最初的写法">自己最初的写法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> l1<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>l1<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                     <span class="token keyword">return</span> l2<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                  <span class="token keyword">if</span><span class="token punctuation">(</span>l2<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                     <span class="token keyword">return</span> l1<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                           <span class="token class-name">ListNode</span> first<span class="token punctuation">;</span>                <span class="token class-name">ListNode</span> f1<span class="token operator">=</span>l1<span class="token punctuation">;</span>                <span class="token class-name">ListNode</span> f2<span class="token operator">=</span>l2<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>f1<span class="token punctuation">.</span>val <span class="token operator">></span>f2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    first<span class="token operator">=</span>f2<span class="token punctuation">;</span>                    f2<span class="token operator">=</span>f2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                     first<span class="token operator">=</span>f1<span class="token punctuation">;</span>                    f1<span class="token operator">=</span>f1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token class-name">ListNode</span> res<span class="token operator">=</span>first<span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>f1 <span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> f2 <span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>f1<span class="token punctuation">.</span>val <span class="token operator">></span>f2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    first<span class="token punctuation">.</span>next<span class="token operator">=</span>f2<span class="token punctuation">;</span>                    f2<span class="token operator">=</span>f2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    first<span class="token operator">=</span>first<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    first<span class="token punctuation">.</span>next<span class="token operator">=</span>f1<span class="token punctuation">;</span>                    f1<span class="token operator">=</span>f1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    first<span class="token operator">=</span>first<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                     <span class="token punctuation">&#125;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>f1<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    first<span class="token punctuation">.</span>next<span class="token operator">=</span>f1<span class="token punctuation">;</span>                    f1<span class="token operator">=</span>f1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    first<span class="token operator">=</span>first<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>f2<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    first<span class="token punctuation">.</span>next<span class="token operator">=</span>f2<span class="token punctuation">;</span>                    f2<span class="token operator">=</span>f2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    first<span class="token operator">=</span>first<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优化">优化</h3><p>上述写法有两个可以优化的点 1.可以设置一个空起点，返回值直接返回空起点的下一个节点 这样就可以省略最初起点的代码 <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ListNode</span> first<span class="token punctuation">;</span>               <span class="token class-name">ListNode</span> f1<span class="token operator">=</span>l1<span class="token punctuation">;</span>               <span class="token class-name">ListNode</span> f2<span class="token operator">=</span>l2<span class="token punctuation">;</span>               <span class="token keyword">if</span><span class="token punctuation">(</span>f1<span class="token punctuation">.</span>val <span class="token operator">></span>f2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                   first<span class="token operator">=</span>f2<span class="token punctuation">;</span>                   f2<span class="token operator">=</span>f2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    first<span class="token operator">=</span>f1<span class="token punctuation">;</span>                   f1<span class="token operator">=</span>f1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span>               <span class="token class-name">ListNode</span> res<span class="token operator">=</span>first<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>2.由于这是链表，不是数组，所以当执行完第一个while循环时（即有一个链表已经完全加入新链表中），这时只用将剩余链表的头结点接到新节点的后面即可，不用使用循环</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>          cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化后 <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> l1<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 类似归并排序中的合并过程</span>        <span class="token class-name">ListNode</span> dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> l2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 任一为空，直接连接另一条链表</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dummyHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="括号生成"><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h2><p>就是深度优先，递归实现 ### 最初自己的写法 <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> res<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">StringBuilder</span> temp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">generateParenthesis</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>n<span class="token operator">=</span>n<span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>r<span class="token operator">==</span>n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">&lt;</span>n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            temp<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"("</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>            temp<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>temp<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        temp<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        temp<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>temp<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> 面试的时候最好还是不要使用StringBuilder 因为删除处理不好，直接使用String相当与空间换时间，速度更快 实际情况好像并没有空间换时间，下面这种未必比上面的快</p><h3 id="不使用stringbuilder">不使用StringBuilder</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">generateParenthesis</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">generate</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">//count1统计“(”的个数，count2统计“)”的个数</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> res <span class="token punctuation">,</span> <span class="token class-name">String</span> ans<span class="token punctuation">,</span> <span class="token keyword">int</span> count1<span class="token punctuation">,</span> <span class="token keyword">int</span> count2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span> count1 <span class="token operator">></span> n <span class="token operator">||</span> count2 <span class="token operator">></span> count1 <span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>count1 <span class="token operator">==</span> n <span class="token operator">&amp;&amp;</span> count2 <span class="token operator">==</span>n<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>           res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>             <span class="token class-name">String</span> ans1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">generate</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> ans<span class="token operator">+</span><span class="token string">"("</span><span class="token punctuation">,</span> count1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> count2<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">generate</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> ans1<span class="token operator">+</span><span class="token string">")"</span><span class="token punctuation">,</span> count1<span class="token punctuation">,</span> count2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="合并k个升序链表"><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23.合并K个升序链表</a></h2><h3 id="最笨的办法循环比较找出最小的节点连到后面">最笨的办法，循环比较找出最小的节点连到后面</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> lists<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>lists<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>lists<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             <span class="token keyword">return</span> lists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">ListNode</span> first<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> res<span class="token operator">=</span>first<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> is<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             <span class="token keyword">int</span> next<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>lists<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>lists<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>val<span class="token operator">&lt;</span>lists<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    next<span class="token operator">=</span>i<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>lists<span class="token punctuation">[</span>next<span class="token punctuation">]</span> <span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">&amp;&amp;</span> lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token keyword">null</span>  <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    next<span class="token operator">=</span>i<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>lists<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            first<span class="token punctuation">.</span>next<span class="token operator">=</span>lists<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token punctuation">;</span>            first<span class="token operator">=</span>first<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            lists<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token operator">=</span>lists<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分治法">分治法</h3><p>分治法就是化繁为简</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;两数之和&quot;&gt;两数之和&lt;/h3&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://rds49.github.io/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://rds49.github.io/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://rds49.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
